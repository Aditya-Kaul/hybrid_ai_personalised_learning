[MISSING_PAGE_EMPTY:1]

[MISSING_PAGE_EMPTY:2]

## A Few Words on Copyright

Hil My name is Alexander Shvets. I'm the author of the book **Dive Into Design Patterns** and the online course

**Dive Into Refactoring**.

This book is for your personal use only.

Please don't share it with any third parties except your family members. If you'd like to share the book with a friend or colleague, buy and send them a new copy.

All profit from the sale of my books and courses is spent on the development of **Refactoring.Guru**. Each copy sold helps the project immensely and brings the moment of a new book release a little bit closer.

## 10 Alexander Shvets, Refactoring.Guru, 2019

**support@refactoring.guru**

## 11 Illustrations: Dmitry Zhart

Editing: Andrew Wetmore, Rhyan Solomon_1 dedicate this book to my wife, Maria. If it hadn't been for her, l'd probably have finished the book some 30 years later._Table of Contents

Table of Contents

How to Read This Book

INTRODUCTION TO OOP

Basics of OOP

8

Pillars of OOP

13

Relations Between Objects

20

INTRODUCTION TO DESIGN PATTERNS

23

What's a Design Pattern?

24

Why Should I Learn Patterns?

28

SOFTWARE DESIGN PRINCIPLES

29

Features of Good Design

30

Design Principles

34

\(\lx@sectionsign\) Encapsulate What Varies

35

\(\lx@sectionsign\) Program to an Interface, not an Implementation.39

\(\lx@sectionsign\) Favor Composition Over Inheritance

44

SOLID Principles

48

\(\lx@sectionsign\) Single Responsibility Principle

49

\(\lx@sectionsign\) Open/Closed Principle

51

\(\lx@sectionsign\) Liskov Substitution Principle

54

\(\lx@sectionsign\) Interface Segregation Principle

61

\(\lx@sectionsign\) Dependency Inversion PrincipleTable of Contents

CATALOG OF DESIGN PATTERNS
68

Craational Design Patterns
69

\(\lx@sectionsign\) Factory Method
71

\(\lx@sectionsign\) Abstract Factory
87

\(\lx@sectionsign\) Builder
103

\(\lx@sectionsign\) Prototype
122

\(\lx@sectionsign\) Singleton
136

Structural Design Patterns
146

\(\lx@sectionsign\) Adapter
149

\(\lx@sectionsign\) Bridge
162

\(\lx@sectionsign\) Composite
177

\(\lx@sectionsign\) Decorator
191

\(\lx@sectionsign\) Facade
209

\(\lx@sectionsign\) Flyweight
219

\(\lx@sectionsign\) Proxy
233

Behavioral Design Patterns
246

\(\lx@sectionsign\) Chain of Responsibility
250

\(\lx@sectionsign\) Command
268

\(\lx@sectionsign\) Iterator
289

\(\lx@sectionsign\) Mediator
304

\(\lx@sectionsign\) Memento
320

\(\lx@sectionsign\) Observer
336

\(\lx@sectionsign\) State
352

\(\lx@sectionsign\) Strategy
368

\(\lx@sectionsign\) Template Method
381

\(\lx@sectionsign\) Visitor
393How to read this book

How to Read This Book

This book contains the descriptions of 22 classic design patterns formulated by the "Gang of Four" (or simply GoF) in 1994.

Each chapter explores a particular pattern. Therefore, you can read from cover to cover or by picking the patterns you're interested in.

Many patterns are related, so you can easily jump from topic to topic using numerous anchors. The end of each chapter has a list of links between the current pattern and others. If you see the name of a pattern that you haven't seen yet, just keep reading\(-\)this item will appear in one of the next chapters.

Design patterns are universal. Therefore, all code samples in this book are written in pseudocode that doesn't constrain the material to a particular programming language.

Prior to studying patterns, you can refresh your memory by going over the **key terms of object-oriented programming**. That chapter also explains the basics of UML diagrams, which is useful because the book has tons of them. Of course, if you already know all of that, you can proceed to **learning patterns** right away.

[MISSING_PAGE_EMPTY:8]

# Basics of OOP

Object-oriented programming is a paradigm based on the concept of wrapping pieces of data, and behavior related to that data, into special bundles called objects, which are constructed from a set of "blueprints", defined by a programmer, called classes.

## Objects, classes

Do you like cats? I hope you do because I'll try to explain the OOP concepts using various cat examples.

Say you have a cat named Oscar. Oscar is an object, an instance of the Cat class. Every cat has a lot of standard attributes: name, sex, age, weight, color, favorite food, etc. These are the class's _fields_.

All cats also behave similarly: they breathe, eat, run, sleep and meow. These are the class's _methods_. Collectively, fields and methods can be referenced as the _members_ of their class.

Data stored inside the object's fields is often referenced as _state_, and all the object's methods define its _behavior_.

_Objects are instances of classes._Luna, your friend's cat, is also an instance of the cat class. It has the same set of attributes as Oscar. The difference is in values of these attributes: her sex is female, she has a different color, and weighs less.

So a _class_ is like a blueprint that defines the structure for _objects_, which are concrete instances of that class.

### Class hierarchies

Everything fine and dandy when we talk about one class. Naturally, a real program contains more than a single class. Some of these classes might be organized into **class hierarchies**. Let's find out what that means.

Say your neighbor has a dog called Fido. It turns out, dogs and cats have a lot in common: name, sex, age, and color are attributes of both dogs and cats. Dogs can breathe, sleep and run the same way cats do. So it seems that we can define the base Animal class that would list the common attributes and behaviors.

A parent class, like the one we've just defined, is called a **superclass**. Its children are **subclasses**. Subclasses inherit state and behavior from their parent, defining only attributes or behaviors that differ. Thus, the Cat class would have the new method, and the \(\log\) class the bark method.

Assuming that we have a related business requirement, we can go even further and extract a more general class for all living Organisms which will become a superclass for Animals and Plants. Such a pyramid of classes is a **hierarchy**. In such a hierarchy, the Cat class inherits everything from both the Animal and Organism classes.

Subclasses can override the behavior of methods that they inherit from parent classes. A subclass can either completely replace the default behavior or just enhance it with some extra stuff.

[MISSING_PAGE_EMPTY:14]

_Abstraction_ is a model of a real-world object or phenomenon, limited to a specific context, which represents all details relevant to this context with high accuracy and omits all the rest.

## Encapsulation

To start a car engine, you only need to turn a key or press a button. You don't need to connect wires under the hood, rotate the crankshaft and cylinders, and initiate the power cycle of the engine. These details are hidden under the hood of the car. You have only a simple interface: a start switch, a steering wheel and some pedals. This illustrates how each object has an **interface\(-\)**a public part of an object, open to interactions with other objects.

_Encapsulation_ is the ability of an object to hide parts of its state and behaviors from other objects, exposing only a limited interface to the rest of the program.

_To encapsulate_ something means to make it private, and thus accessible only from within of the methods of its own class. There's a little bit less restrictive mode called protected that makes a member of a class available to subclasses as well.

Interfaces and abstract classes/methods of most programming languages are based on the concepts of abstraction and encapsulation. In modern object-oriented programming languages, the interface mechanism (usually declared with the interface of protocol keyword) lets you define contracts of interaction between objects. That's one of the reasons why the interfaces only care about behaviors of objects, and why you can't declare a field in an interface.

The fact that the word _interface_ stands for a public part of an object, while there's also the interface type in most programming languages, is very confusing. I'm with you on that.

Imagine that you have a FlyingTransport interface with a method fly(origin, destination, passengers). When designing an air transportation simulator, you could restrict the Airport class to work only with objects that implement the FlyingTransport interface. After this, you can be sure that any object passed to an airport object, whether it's an Airplane, a Helicopter or a freaking DomesticatedGryphon would be able to arrive or depart from this type of airport.

You could change the implementation of the fly method in these classes in any way you want. As long as the signature of the method remains the same as declared in the interface, all instances of the Airport class can work with your flying objects just fine.

### Inheritance

_Inheritance_ is the ability to build new classes on top of existing ones. The main benefit of inheritance is code reuse. If you want to create a class that's slightly different from an existing one, there's no need to duplicate code. Instead, you extend the existing class and put the extra functionality into a resulting subclass, which inherits fields and methods of the superclass.

The consequence of using inheritance is that subclasses have the same interface as their parent class. You can't hide a method in a subclass if it was declared in the superclass. You must also implement all abstract methods, even if they don't make sense for your subclass.

In most programming languages a subclass can extend only one superclass. On the other hand, any class can implement several interfaces at the same time. But, as I mentioned before,if a superclass implements an interface, all of its subclasses must also implement it.

### Polymorphism

Let's look at some animal examples. Most Animals can make sounds. We can anticipate that all subclasses will need to override the base makeSound method so each subclass can emit the correct sound; therefore we can declare it _abstract_ right away. This lets us omit any default implementation of the method in the superclass, but force all subclasses to come up with their own.

Imagine that we've put several cats and dogs into a large bag. Then, with closed eyes, we take the animals one-by-one out of the bag. After taking an animal from the bag, we don't know for sure what it is. However, if we cuddle it hard enough, the animal will emit a specific sound of joy, depending on its concrete class.

1 bag = [new Cat(), new Dog()]; 2 foreach (Animal a : bag)
4 a.makeSound()
5
6 // Mew!
7 // Wool!

The program doesn't know the concrete type of the object contained inside the a variable; but, thanks to the special mechanism called _polymorphism_, the program can trace down the subclass of the object whose method is being executed and run the appropriate behavior.

_Polymorphism_ is the ability of a program to detect the real class of an object and call its implementation even when its real type is unknown in the current context.

You can also think of polymorphism as the ability of an object to "pretend" to be something else, usually a class it extends or an interface it implements. In our example, the dogs and cats in the bag were pretending to be generic animals.

### Relations Between Objects

In addition to _inheritance_ and _implementation_ that we've already seen, there are other types of relations between objects that we haven't talked about yet.

_UML Association. Professor communicates with students._

_Association_ is a type of relationship in which one object uses or interacts with another. In UML diagrams the association relationship is shown by a simple arrow drawn from an object and pointing to the object it uses. By the way, having a bi-directional association is a completely normal thing. In this case, the arrow has a point at each end.

In general, you use an association to represent something like a field in a class. The link is always there, in that you can always ask an order for its customer. It need not actually be a field, if you are modeling from a more interface perspective, it can just indicate the presence of a method that will return the order's customer.

_Dependency_ is a weaker variant of association that usually implies that there's no permanent link between objects. Dependency typically (but not always) implies that an object accepts another object as a method parameter, instantiates, or uses another object. Here's how you can spot a dependency between classes: a dependency exists between two classes if changes to the definition of one class result in modifications in another class.

_Composition_ is a "whole-part" relationship between two objects, one of which is composed of one or more instances of the other. The distinction between this relation and others is that the component can only exist as a part of the container. In UML the composition relationship is shown by a line with a filled diamond at the container end and an arrow at the end pointing toward the component.

#### 4.2.2 Aggregation

is a less strict variant of composition, where one object merely contains a reference to another. The container doesn't control the life cycle of the component. The component can exist without the container and can be linked to several containers at the same time. In UML the aggregation relationship is drawn the same as for composition, but with an empty diamond at the arrow's base.

[MISSING_PAGE_EMPTY:24]

[MISSING_PAGE_EMPTY:25]

## 5 What does the pattern consist of?

Most patterns are described very formally so people can reproduce them in many contexts. Here are the sections that are usually present in a pattern description:

* **Intent** of the pattern briefly describes both the problem and the solution.
* **Motivation** further explains the problem and the solution the pattern makes possible.
* **Structure** of classes shows each part of the pattern and how they are related.
* **Code example** in one of the popular programming languages makes it easier to grasp the idea behind the pattern. Some pattern catalogs list other useful details, such as applicability of the pattern, implementation steps and relations with other patterns.

## 6 Classification of patterns

Design patterns differ by their complexity, level of detail and scale of applicability to the entire system being designed. I like the analogy to road construction: you can make an intersection safer by either installing some traffic lights or building an entire multi-level interchange with underground passages for pedestrians.

The most basic and low-level patterns are often called _idioms_. They usually apply only to a single programming language.

The most universal and high-level patterns are _architectural patterns_. Developers can implement these patterns in virtually any language. Unlike other patterns, they can be used to design the architecture of an entire application.

In addition, all patterns can be categorized by their _intent_, or purpose. This book covers three main groups of patterns:

* **Creational patterns** provide object creation mechanisms that increase flexibility and reuse of existing code.
* **Structural patterns** explain how to assemble objects and classes into larger structures, while keeping the structures flexible and efficient.
* **Behavioral patterns** take care of effective communication and the assignment of responsibilities between objects.

## 5 Who invented patterns?

That's a good, but not a very accurate, question. Design patterns aren't obscure, sophisticated concepts\(-\)quite the opposite. Patterns are typical solutions to common problems in object-oriented design. When a solution gets repeated over and over in various projects, someone eventually puts a name to it and describes the solution in detail. That's basically how a pattern gets discovered.

The concept of patterns was first described by Christopher Alexander in _A Pattern Language: Towns, Buildings, Construction_**1**. The book describes a "language" for designing the urban environment. The units of this language are patterns. They may describe how high windows should be, how many levels a building should have, how large green areas in a neighborhood are supposed to be, and so on.

The idea was picked up by four authors: Erich Gamma, John Vlissides, Ralph Johnson, and Richard Helm. In 1995, they published _Design Patterns: Elements of Reusable Object-Oriented Software_**2**, in which they applied the concept of design patterns to programming. The book featured 23 patterns solving various problems of object-oriented design and became a best-seller very quickly. Due to its lengthy name, people started to call it "the book by the gang of four" which was soon shortened to simply "the GOF book".

Since then, dozens of other object-oriented patterns have been discovered. The "pattern approach" became very popular in other programming fields, so lots of other patterns now exist outside of object-oriented design as well.

## References

* [1]_A Pattern Language: Towns, Buildings, Construction_: [https://refactoring.guru/pattern-language-book](https://refactoring.guru/pattern-language-book)
* [2]_Design Patterns: Elements of Reusable Object-Oriented Software_: [https://refactoring.guru/gof-book](https://refactoring.guru/gof-book)

## Why Should Learn Patterns?

The truth is that you might manage to work as a programmer for many years without knowing about a single pattern. A lot of people do just that. Even in that case, though, you might be implementing some patterns without even knowing it. So why would you spend time learning them?

* Design patterns are a toolkit of **tried and tested solutions** to common problems in software design. Even if you never encounter these problems, knowing patterns is still useful because it teaches you how to solve all sorts of problems using principles of object-oriented design.
* Design patterns define a common language that you and your teammates can use to communicate more efficiently. You can say, "Oh, just use a Singleton for that," and everyone will understand the idea behind your suggestion. No need to explain what a singleton is if you know the pattern and its name.

## Chapter 3 Outline Design

Features of Good Design

Before we proceed to the actual patterns, let's discuss the process of designing software architecture: things to aim for and things you'd better avoid.

### Code reuse

Cost and time are two of the most valuable metrics when developing any software product. Less time in development means entering the market earlier than competitors. Lower development costs mean more money is left for marketing and a broader reach to potential customers.

**Code reuse** is one of the most common ways to reduce development costs. The intent is pretty obvious: instead of developing something over and over from scratch, why don't we reuse existing code in new projects?

The idea looks great on paper, but it turns out that making existing code work in a new context usually takes extra effort. Tight coupling between components, dependencies on concrete classes instead of interfaces, hardcoded operations--all of this reduces flexibility of the code and makes it harder to reuse it.

Using design patterns is one way to increase flexibility of software components and make them easier to reuse. However,this sometimes comes at the price of making the components more complicated.

Here's a piece of wisdom from Erich Gamma **1**, one of the founding fathers of design patterns, about the role of design patterns in code reuse:

\[\begin{array}{l}\includegraphics[width=142.26378pt]{Erich Gamma on Flexibility and Reuse: [https://refactoring.guru/gamma-interview](https://refactoring.guru/gamma-interview)}\end{array}\]

Frameworks are at the highest level. They really try to distill your design decisions. They identify the key abstractions for solving a problem, represent them by classes and define relationships between them. JUnit is a small framework, for example. It is the "Hello, world" of frameworks. It has Test, TestCase, TestSuite and relationships defined.

A framework is typically larger-grained than just a single class. Also, you hook into frameworks by subclassing somewhere. They use the so-called Hollywood principle of "don't call us, we'll call you." The framework lets you define your custom behavior, and it will call you when it's your turn to do something. Same with JUnit, right? It calls you when it wants to execute a test for you, but the rest happens in the framework.

\[\begin{array}{l}\includegraphics[width=142.26378pt]{Erich Gamma on Flexibility and Reuse: [https://refactoring.guru/gamma-interview](https://refactoring.guru/gamma-interview)}\end{array}\]

1. Erich Gamma on Flexibility and Reuse: [https://refactoring.guru/gamma-interview](https://refactoring.guru/gamma-interview)There also is a middle level. This is where I see patterns. Design patterns are both smaller and more abstract than frameworks. They're really a description about how a couple of classes can relate to and interact with each other. The level of reuse increases when you move from classes to patterns and finally frameworks.

What is nice about this middle layer is that patterns offer reuse in a way that is less risky than frameworks. Building a framework is high-risk and a significant investment. Patterns let you reuse design ideas and concepts independently of concrete code.

Extensibility

Change is the only constant thing in a programmer's life.

You released a video game for Windows, but now people ask for a macOS version.

You created a GUI framework with square buttons, but several months later round buttons become a trend.

You designed a brilliant e-commerce website architecture, but just a month later customers ask for a feature that would let them accept phone orders.

Each software developer has dozens of similar stories. There are several reasons why this happens.

First, we understand the problem better once we start to solve it. Often by the time you finish the first version of an app, you're ready to rewrite it from scratch because now you understand many aspects of the problem much better. You have also grown professionally, and your own code now looks like crap.

Something beyond your control has changed. This is why so many dev teams pivot from their original ideas into something new. Everyone who relied on Flash in an online application has been reworking or migrating their code as browser after browser drops support for Flash.

The third reason is that the goalposts move. Your client was delighted with the current version of the application, but now sees eleven "little" changes he'd like so it can do other things he never mentioned in the original planning sessions. These aren't frivolous changes: your excellent first version has shown him that even more is possible.

There's a bright side: if someone asks you to change something in your app, that means someone still cares about it.

That's why all seasoned developers try to provide for possible future changes when designing an application's architecture.

Design Principles

What is good software design? How would you measure it? What practices would you need to follow to achieve it? How can you make your architecture flexible, stable and easy to understand?

These are the great questions; but, unfortunately, the answers are different depending on the type of application you're building. Nevertheless, there are several universal principles of software design that might help you answer these questions for your own project. Most of the design patterns listed in this book are based on these principles.

## 5. Design Principles and Encapsulate What Varies

In the same way, you can isolate the parts of the program that vary in independent modules, protecting the rest of the code from adverse effects. As a result, you spend less time getting the program back into working shape, implementing and testing the changes. The less time you spend making changes, the more time you have for implementing features.

Encapsulation on a method level

Say you're making an e-commerce website. Somewhere in your code, there's a getOrderTotal method that calculates a grand total for the order, including taxes.

We can anticipate that tax-related code might need to change in the future. The tax rate depends on the country, state or even city where the customer resides, and the actual formula may change over time due to new laws or regulations. As a result, you'll need to change the getOrderTotal method quite often. But even the method's name suggests that it doesn't care about _how_ the tax is calculated.

```
1methodgetOrderTotal(order)is
2total=0
3foreachiteminorder.lineItems
4total+=item.price*item.quantity
5
6if(order.country=="US")
7total+=total*0.07//USsalestax
8elseif(order.country=="EU"):
9total+=total*0.20//EuropeanVAT
10
11returntotal
```

_BEFORE: tax calculation code is mixed with the rest of the method's code._

You can extract the tax calculation logic into a separate method, hiding it from the original method.

1methodgetOrderTotal(order)is
2total=0
3foreachiteminorder.lineItems
4total+=item.price*item.quantity
5
6total+=total*getTaxRate(order.country)
7
8returntotal
9
10methodgetTaxRate(country)is
11if(country=="US")
12return0.07//USalestax
13elseif(country=="EU")
14return0.20//EuropeanVAT
15else
16return0

_AFTER: you can get the tax rate by calling a designated method._

Tax-related changes become isolated inside a single method. Moreover, if the tax calculation logic becomes too complicated, it's now easier to move it to a separate class.

### Encapsulation on a class level

Over time you might add more and more responsibilities to a method which used to do a simple thing. These added behaviors often come with their own helper fields and methods that eventually blur the primary responsibility of the containing class. Extracting everything to a new class might make things much more clear and simple.

* [10] _AFTER: tax calculation is hidden from the order class._Program to an Interface, not an Implementation

Program to an interface, not an implementation. Depend

on abstractions, not on concrete classes.

You can tell that the design is flexible enough if you can easily extend it without breaking any existing code. Let's make sure that this statement is correct by looking at another cat example. A Cat that can eat any food is more flexible than one that can eat just sausages. You can still feed the first cat with sausages because they are a subset of "any food"; however, you can extend that cat's menu with any other food.

When you want to make two classes collaborate, you can start by making one of them dependent on the other. Hell, I often start by doing that myself. However, there's another, more flexible way to set up collaboration between objects:

1. Determine what exactly one object needs from the other: which methods does it execute?
2. Describe these methods in a new interface or abstract class.
3. Make the class that is a dependency implement this interface.
4. Now make the second class dependent on this interface rather than on the concrete class. You still can make it work with objects of the original class, but the connection is now much more flexible.

After making this change, you won't probably feel any immediate benefit. On the contrary, the code has become more complicated than it was before. However, if you feel that this might be a good extension point for some extra functionality, or that some other people who use your code might want to extend it here, then go for it.

## Example

Let's look at another example which illustrates that working with objects through interfaces might be more beneficial than depending on their concrete classes. Imagine that you're creating a software development company simulator. You have different classes that represent various employee types.

In the beginning, the Company class is tightly coupled to concrete classes of employees. However, despite the difference in their implementations, we can generalize various work-relatedmethods and then extract a common interface for all employee classes.

After doing that, we can apply polymorphism inside the Company class, treating various employee objects via the Employee interface.

The Company class remains coupled to the employee classes. This is bad because if we introduce new types of companies that work with other types of employees, we'll need to override most of the Company class instead of reusing that code.

To solve this problem, we could declare the method for getting employees as _abstract_. Each concrete company will implement this method differently, creating only those employees that it needs.

After this change, the Company class has become independent from various employee classes. Now you can extend this class and introduce new types of companies and employees while still reusing a portion of the base company class. Extending the base company class doesn't break any existing code that already relies on it.

By the way, you've just seen applying a design pattern in action! That was an example of the _Factory Method_ pattern. Don't worry: we'll discuss it later in detail.

[MISSING_PAGE_EMPTY:45]

* **Subclasses are tightly coupled to superclasses.** Any change in a superclass may break the functionality of subclasses.
* **Trying to reuse code through inheritance can lead to creating parallel inheritance hierarchies.** Inheritance usually takes place in a single dimension. But whenever there are two or more dimensions, you have to create lots of class combinations, bloating the class hierarchy to a ridiculous size. There's an alternative to inheritance called _composition._ Whereas inheritance represents the "is a" relationship between classes (a car _is a_ transport), composition represents the "has a" relationship (a car _has an_ engine). I should mention that this principle also applies to aggregation--a more relaxed variant of composition where one object may have a reference to the other one but doesn't manage its lifecycle. Here's an example: a car _has a_ driver, but he or she may use another car or just walk _without the car_.

### Example

Imagine that you need to create a catalog app for a car manufacturer. The company makes both cars and trucks; they can be either electric or gas; all models have either manual controls or an autopilot.

As you see, each additional parameter results in multiplying the number of subclasses. There's a lot of duplicate code between subclasses because a subclass can't extend two classes at the same time.

You can solve this problem with composition. Instead of car objects implementing a behavior on their own, they can delegate it to other objects.

The added benefit is that you can replace a behavior at runtime. For instance, you can replace an engine object linked to a car object just by assigning a different engine object to the car.

This structure of classes resembles the _Strategy_ pattern, which we'll go over later in this book.

SOLID Principles

Now that you know the basic design principles, let's take a look at five that are commonly known as the SOLID principles. Robert Martin introduced them in the book _Agile Software Development_, _Principles_, _Patterns_, _and Practices_1.

_SOLID_ is a mnemonic for five design principles intended to make software designs more understandable, flexible and maintainable.

As with everything in life, using these principles mindlessly can cause more harm than good. The cost of applying these principles into a program's architecture might be making it more complicated than it should be. I doubt that there's a successful software product in which all of these principles are applied at the same time. Striving for these principles is good, but always try to be pragmatic and don't take everything written here as dogma.

Try to make every class responsible for a single part of the functionality provided by the software, and make that responsibility entirely encapsulated by (you can also say _hidden within_) the class.

The main goal of this principle is reducing complexity. You don't need to invent a sophisticated design for a program that only has about 200 lines of code. Make a dozen methods pretty, and you'll be fine.

The real problems emerge when your program constantly grows and changes. At some point classes become so big that you can no longer remember their details. Code navigation slows down to a crawl, and you have to scan through whole classes or even an entire program to find specific things. The number of entities in program overflows your brain stack, and you feel that you're losing control over the code.

There's more: if a class does too many things, you have to change it every time one of these things changes. While doing that, you're risking breaking other parts of the class which you didn't even intend to change.

If you feel that it's becoming hard to focus on specific aspects of the program one at a time, remember the single responsibility principle and check whether it's time to divide some classes into parts.

### Example

The Employee class has several reasons to change. The first reason might be related to the main job of the class: managing employee data. However, there's another reason: the format of the timesheet report may change over time, requiring you to change the code within the class.

Solve the problem by moving the behavior related to printing timesheet reports into a separate class. This change lets you move other report-related stuff to the new class.

### Example

The _Employee_ class has several reasons to change. The first reason might be related to the main job of the class: managing employee data. However, there's another reason: the format of the timesheet report may change over time, requiring you to change the code within the class.

Solve the problem by moving the behavior related to printing timesheet reports into a separate class. This change lets you move other report-related stuff to the new class.

[MISSING_PAGE_FAIL:52]

the original class that you want to behave differently. You'll achieve your goal but also won't break any existing clients of the original class.

This principle isn't meant to be applied for all changes to a class. If you know that there's a bug in the class, just go on and fix it; don't create a subclass for it. A child class shouldn't be responsible for the parent's issues.

## Example

You have an e-commerce application with an Order class that calculates shipping costs and all shipping methods are hard-coded inside the class. If you need to add a new shipping method, you have to change the code of the Order class and risk breaking it.

_BEFORE: you have to change the Order class whenever you add a new shipping method to the app._You can solve the problem by applying the _Strategy_ pattern. Start by extracting shipping methods into separate classes with a common interface.

Now when you need to implement a new shipping method, you can derive a new class from the Shipping interface without touching any of the Order class' code. The client code of the Order class will link orders with a shipping object of the new class whenever the user selects this shipping methods in the UI.

As a bonus, this solution let you move the delivery time calculation to more relevant classes, according to the _single responsibility principle_.

This means that the subclass should remain compatible with the behavior of the superclass. When overriding a method, extend the base behavior rather than replacing it with something else entirely.

The substitution principle is a set of checks that help predict whether a subclass remains compatible with the code that was able to work with objects of the superclass. This concept is critical when developing libraries and frameworks because your classes are going to be used by other people whose code you can't directly access and change.

Unlike other design principles which are wide open for interpretation, the substitution principle has a set of formal requirements for subclasses, and specifically for their methods. Let's go over this checklist in detail.

1. This principle is named by Barbara Liskov, who defined it in 1987 in her work _Data abstraction and hierarchy_: **[https://refactoring.guru/liskov/dah](https://refactoring.guru/liskov/dah)*** **Parameter types in a method of a subclass should _match_ or be _more abstract_ than parameter types in the method of the superclass. Sounds confusing? Let's have an example.
* Say there's a class with a method that's supposed to feed cats: feed(Cat c). Client code always passes cat objects into this method.
* **Good:** Say you created a subclass that overrode the method so that it can feed any animal (a superclass of cats): feed(Animal c). Now if you pass an object of this subclass instead of an object of the superclass to the client code, everything would still work fine. The method can feed all animals, so it can still feed any cat passed by the client.
* **Bad:** You created another subclass and restricted the feeding method to only accept Bengal cats (a subclass of cats): feed(BengaLat c). What will happen to the client code if you link it with an object like this instead of with the original class? Since the method can only feed a specific breed of cats, it won't serve generic cats passed by the client, breaking all related functionality.
* **The return type in a method of a subclass should _match_ or be _a subtype_ of the return type in the method of the superclass. As you can see, requirements for a return type are inverse to requirements for parameter types.

Say you have a class with a method buyCat(): Cat. The client code expects to receive any cat as a result of executing this method.
* **Good:** A subclass overrides the method as follows: buyCat(): BengalCat. The client gets a Bengal cat, which is still a cat, so everything is okay.
* **Bad:** A subclass overrides the method as follows: buyCat(): Animal. Now the client code breaks since it receives an unknown generic animal (an alligator? a bear?) that doesn't fit a structure designed for a cat. Another anti-example comes from the world of programming languages with dynamic typing: the base method returns a string, but the overridden method returns a number.
* **A method in a subclass shouldn't throw types of exceptions which the base method isn't expected to throw.** In other words, types of exceptions should _match_ or be _subtypes_ of the ones that the base method is already able to throw. This rule comes from the fact that try-catch blocks in the client code target specific types of exceptions which the base method is likely to throw. Therefore, an unexpected exception might slip through the defensive lines of the client code and crash the entire application.

* **A subclass shouldn't strengthen pre-conditions.** For example, the base method has a parameter with type int. If a subclass overrides this method and requires that the value of an argument passed to the method should be positive (by throwing an exception if the value is negative), this strengthens the pre-conditions. The client code, which used to work fine when passing negative numbers into the method, now breaks if it starts working with an object of this subclass.
* **A subclass shouldn't weaken post-conditions.** Say you have a class with a method that works with a database. A method of the class is supposed to always close all opened database connections upon returning a value. You created a subclass and changed it so that database connections remain open so you can reuse them. But the client might not know anything about your intentions. Because it expects the methods to close all the connections, it may simply terminate the program right after calling the method, polluting a system with ghost database connections.
* **Invariants of a superclass must be preserved.** This is probably the least formal rule of all, _Invariants_ are conditions in which an object makes sense. For example, invariants of a cat are having four legs, a tail, ability to meow, etc. The confusing part about invariants is that while they can be defined explicitly in the form of interface contracts or a set of assertions within methods, they could also be implied by certain unit tests and expectations of the client code.

The rule on invariants is the easiest to violate because you might misunderstand or not realize all of the invariants of a complex class. Therefore, the safest way to extend a class is to introduce new fields and methods, and not mess with any existing members of the superclass. Of course, that's not always doable in real life.

* **A subclass shouldn't change values of private fields of the superclass.**_What? How's that even possible_? It turns out some programming languages let you access private members of a class via reflection mechanisms. Other languages (Python, JavaScript) don't have any protection for the private members at all.

### Example

Let's look at an example of a hierarchy of document classes that violates the substitution principle.

The save method in the ReadOnlyDocuments subclass throws an exception if someone tries to call it. The base method doesn't have this restriction. This means that the client code will break if we don't check the document type before saving it.

The resulting code also violates the open/closed principle, since the client code becomes dependent on concrete classes of documents. If you introduce a new document subclass, you'll need to change the client code to support it.

You can solve the problem by redesigning the class hierarchy: a subclass should extend the behavior of a superclass, therefore the read-only document becomes the base class of the hierarchy. The writable document is now a subclass which extends the base class and adds the saving behavior.

### Example

Imagine that you created a library that makes it easy to integrate apps with various cloud computing providers. While in the initial version it only supported Amazon Cloud, it covered the full set of cloud services and features. At the time you assumed that all cloud providers have the same broad spectrum of features as Amazon. But when it came to implementing support for another provider, it turned out that most of the interfaces of the library are too wide. Some methods describe features that other cloud providers just don't have.

While you can still implement these methods and put some stubs there, it wouldn't be a pretty solution. The better approach is to break down the interface into parts. Classes that are able to implement the original interface can now just implement several refined interfaces. Other classes can implement only those interfaces which have methods that make sense for them.

As with the other principles, you can go too far with this one. Don't further divide an interface which is already quite specific. Remember that the more interfaces you create, the more complex your code becomes. Keep the balance.

Usually when designing software, you can make a distinction between two levels of classes.
* **Low-level classes** implement basic operations such as working with a disk, transferring data over a network, connecting to a database, etc.
* **High-level classes** contain complex business logic that directs low-level classes to do something. Sometimes people design low-level classes first and only then start working on high-level ones. This is very common when you start developing a prototype on a new system, and you're not even sure what's possible at the higher level because low-level stuff isn't yet implemented or clear. With such an approach business logic classes tend to become dependent on primitive low-level classes. The dependency inversion principle suggests changing the direction of this dependency.

1. For starters, you need to describe interfaces for low-level operations that high-level classes rely on, preferably in business terms. For instance, business logic should call a method openReport(file) rather than a series of methods openFile(x), readBytes(n), closeFile(x). These interfaces count as high-level ones.
2. Now you can make high-level classes dependent on those interfaces, instead of on concrete low-level classes. This dependency will be much softer than the original one.
3. Once low-level classes implement these interfaces, they become dependent on the business logic level, reversing the direction of the original dependency.

The dependency inversion principle often goes along with the _open/closed principle_: you can extend low-level classes to use with different business logic classes without breaking existing classes.

### Example

In this example, the high-level budget reporting class uses a low-level database class for reading and persisting its data. This means that any change in the low-level class, such as when a new version of the database server gets released, may affect the high-level class, which isn't supposed to care about the data storage details.

You can fix this problem by creating a high-level interface that describes read/write operations and making the reporting class use that interface instead of the low-level class. Then you can change or extend the original low-level class to implement the new read/write interface declared by the business logic.

_AFTER: low-level classes depend on a high-level abstraction._As a result, the direction of the original dependency has been inverted: low-level classes are now dependent on high-level abstractions.

[MISSING_PAGE_EMPTY:69]

Creattional Design Patterns

Creational patterns provide various object creation mechanisms, which increase flexibility and reuse of existing code.

Provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.

Lets you produce families of related objects without specifying their concrete classes.

[MISSING_PAGE_EMPTY:71]

**Factory Method** is a creational design pattern that provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.

* [1] Problem
* [2] Imagine that you're creating a logistics management application. The first version of your app can only handle transportation by trucks, so the bulk of your code lives inside the Truck class.
* [3] After a while, your app becomes pretty popular. Each day you receive dozens of requests from sea transportation companies to incorporate sea logistics into the app.
* [4] _Adding a new class to the program isn't that simple if the rest of the code is already coupled to existing classes._
* [5] Great news, right? But how about the code? At present, most of your code is coupled to the Truck class. Adding Ships into the app would require making changes to the entire codebase. Moreover, if later you decide to add another type of transportation to the app, you will probably need to make all of these changes again.

As a result, you will end up with pretty nasty code, riddled with conditionals that switch the app's behavior depending on the class of transportation objects.

### Solution

The Factory Method pattern suggests that you replace direct object construction calls (using the new operator) with calls to a special _factory_ method. Don't worry: the objects are still created via the new operator, but it's being called from within the factory method. Objects returned by a factory method are often referred to as "products."

At first glance, this change may look pointless: we just moved the constructor call from one part of the program to another. However, consider this: now you can override the factory method in a subclass and change the class of products being created by the method.

There's a slight limitation though: subclasses may return different types of products only if these products have a common base class or interface. Also, the factory method in the base class should have its return type declared as this interface.

For example, both Truck and Ship classes should implement the Transport interface, which declares a method called deliver. Each class implements this method differently: trucks deliver cargo by land, ships deliver cargo by sea. The factory method in the RoadLogistics class returns truck objects, whereas the factory method in the Sealogistics class returns ships.

The code that uses the factory method (often called the _client_ code) doesn't see a difference between the actual products returned by various subclasses. The client treats all the products as abstract Transport.

The client knows that all transport objects are supposed to have the deliver method, but exactly how it works isn't important to the client.

### Structure

Figure 13: The client knows that all transport objects are supposed to have the deliver method, but exactly how it works isn't important to the client.

1. The Product declares the interface, which is common to all objects that can be produced by the creator and its subclasses.
2. **Concrete Products** are different implementations of the product interface.
3. The **Creator** class declares the factory method that returns new product objects. It's important that the return type of this method matches the product interface.

You can declare the factory method as abstract to force all subclasses to implement their own versions of the method. As an alternative, the base factory method can return some default product type.

Note, despite its name, product creation is **not** the primary responsibility of the creator. Usually, the creator class already has some core business logic related to products. The factory method helps to decouple this logic from the concrete product classes. Here is an analogy: a large software development company can have a training department for programmers. However, the primary function of the company as a whole is still writing code, not producing programmers.
4. **Concrete Creators** override the base factory method so it returns a different type of product.

Note that the factory method doesn't have to **create** new instances all the time. It can also return existing objects from a cache, an object pool, or another source.

## # Pseudocode

This example illustrates how the **Factory Method** can be used for creating cross-platform UI elements without coupling the client code to concrete UI classes.

The base dialog class uses different UI elements to render its window. Under various operating systems, these elements may look a little bit different, but they should still behave consistently. A button in Windows is still a button in Linux.

_The cross-platform dialog example._When the factory method comes into play, you don't need to rewrite the logic of the dialog for each operating system. If we declare a factory method that produces buttons inside the base dialog class, we can later create a dialog subclass that returns Windows-styled buttons from the factory method. The subclass then inherits most of the dialog's code from the base class, but, thanks to the factory method, can render Windows-looking buttons on the screen.

For this pattern to work, the base dialog class must work with abstract buttons: a base class or an interface that all concrete buttons follow. This way the dialog's code remains functional, whichever type of buttons it works with.

Of course, you can apply this approach to other UI elements as well. However, with each new factory method you add to the dialog, you get closer to the **Abstract Factory** pattern. Fear not, we'll talk about this pattern later.

1 // The creator class declares the factory method that must
2 // return an object of a product class. The creator's subclasses
3 // usually provide the implementation of this method.
4 **class Dialog is**
5 // The creator may also provide some default implementation
6 // of the factory method.
7 **abstract method createButton()**
8
9 // Note that, despite its name, the creator's primary
10 // responsibility isn't creating products. It usually 11 // contains some core business logic that relies on product
12 // objects returned by the factory method. Subclasses can
13 // indirectly change that business logic by overriding the
14 // factory method and returning a different type of product
15 // from it.
16 method render() is
17 // Call the factory method to create a product object.
18 Button okButton = createButton()
19 // Now use the product.
20 okButton.onClick(closeDialog)
21 okButton.render()
22
23
24 // Concrete creators override the factory method to change the
25 // resulting product's type.
26 class WindowsDialog extends Dialog is
27 method createButton() is
28 return new WindowsButton()
29
29
30 class WebDialog extends Dialog is
31 method createButton() is
32 return new HTMLButton()
33
34
35 // The product interface declares the operations that all
36 // concrete products must implement.
37 interface Button is
38 method render()
39 method onClick(f)
40
41 // Concrete products provide various implementations of the
42 // product interface.

class WindowsButton implements Button is
44 method render(a, b) is
45 // Render a button in Windows style.
46 method onClick(f) is
47 // Bind a native OS click event.
48
49 class HTMLButton implements Button is
50 method render(a, b) is
51 // Return an HTML representation of a button.
52 method onClick(f) is
53 // Bind a web browser click event.
54
55
56 class Application is
57 field dialog: Dialog
58
59 // The application picks a creator's type depending on the
60 // current configuration or environment settings.
61 method initialize() is
62 config = readApplicationConfigFile()
63
64 if (config.OS == "Windows") then
65 dialog = new WindowsDialog()
66 else if (config.OS == "Web") then
67 dialog = new WebDialog()
68 else
69 throw new Exception("Error! Unknown operating system.")
70
71 // The client code works with an instance of a concrete
72 // creator, albeit through its base interface. As long as
73 // the client keeps working with the creator via the base
74 // interface, you can pass it any creator's subclass.

* [75]**method main() is**
* [76]**this.initialize()**
* [77]**dialog.render()**

* [78]**Applicability**

* [79]**Use the Factory Method when you don't know beforehand the exact types and dependencies of the objects your code should work with.**

* [80]**The Factory Method separates product construction code from the code that actually uses the product. Therefore it's easier to extend the product construction code independently from the rest of the code.**

* [81]**For example, to add a new product type to the app, you'll only need to create a new creator subclass and override the factory method in it.**

* [82]**Use the Factory Method when you want to provide users of your library or framework with a way to extend its internal components.**

* [83]**Inheritance is probably the easiest way to extend the default behavior of a library or framework. But how would the framework recognize that your subclass should be used instead of a standard component?**The solution is to reduce the code that constructs components across the framework into a single factory method and let anyone override this method in addition to extending the component itself.

Let's see how that would work. Imagine that you write an app using an open source UI framework. Your app should have round buttons, but the framework only provides square ones. You extend the standard Button class with a glorious RoundButton subclass. But now you need to tell the main UIFramework class to use the new button subclass instead of a default one.

To achieve this, you create a subclass UIMithRoundButtons from a base framework class and override its createButton method. While this method returns Button objects in the base class, you make your subclass return RoundButton objects. Now use the UIMithRoundButtons class instead of UIFramework. And that's about it!

Use the Factory Method when you want to save system resources by reusing existing objects instead of rebuilding them each time.

You often experience this need when dealing with large, resource-intensive objects such as database connections, file systems, and network resources.

[MISSING_PAGE_EMPTY:84]

Add an empty factory method inside the creator class. The return type of the method should match the common product interface.
3. In the creator's code find all references to product constructors. One by one, replace them with calls to the factory method, while extracting the product creation code into the factory method. You might need to add a temporary parameter to the factory method to control the type of returned product. At this point, the code of the factory method may look pretty ugly. It may have a large switch operator that picks which product class to instantiate. But don't worry, we'll fix it soon enough.
4. Now, create a set of creator subclasses for each type of product listed in the factory method. Override the factory method in the subclasses and extract the appropriate bits of construction code from the base method.
5. If there are too many product types and it doesn't make sense to create subclasses for all of them, you can reuse the control parameter from the base class in subclasses. For instance, imagine that you have the following hierarchy of classes: the base Mail class with a couple of subclasses: AirMail and GroundMail ; the Transport classes are Plane,Truck and Train. While the AirMail class only uses Plane objects, GroundMail may work with both Truck and Train objects. You can create a new subclass (say TrainMail ) to handle both cases, but there's another option. The client code can pass an argument to the factory method of the GroundMail class to control which product it wants to receive.
6. If, after all of the extractions, the base factory method has become empty, you can make it abstract. If there's something left, you can make it a default behavior of the method.

### Pros and Cons

You avoid tight coupling between the creator and the concrete products.

_Single Responsibility Principle._ You can move the product creation code into one place in the program, making the code easier to support.

_Open/Closed Principle._ You can introduce new types of products into the program without breaking existing client code.

The code may become more complicated since you need to introduce a lot of new subclasses to implement the pattern. The best case scenario is when you're introducing the pattern into an existing hierarchy of creator classes.

Relations with Other Patterns

Many designs start by using **Factory Method** (less complicated and more customizable via subclasses) and evolve toward **Abstract Factory**, **Prototype**, or **Builder** (more flexible, but more complicated).

**Abstract Factory** classes are often based on a set of **Factory Methods**, but you can also use **Prototype** to compose the methods on these classes.

You can use **Factory Method** along with **Iterator** to let collection subclasses return different types of iterators that are compatible with the collections.

**Prototype** isn't based on inheritance, so it doesn't have its drawbacks. On the other hand, _Prototype_ requires a complicated initialization of the cloned object. **Factory Method** is based on inheritance but doesn't require an initialization step.

**Factory Method** is a specialization of **Template Method**. At the same time, a _Factory Method_ may serve as a step in a large _Template Method_.

**Abstract Factory** is a creational design pattern that lets your produce families of related objects without specifying their concrete classes.

* 3Problem Imagine that you're creating a furniture shop simulator. Your code consists of classes that represent:

1. A family of related products, say: Chair + Sofa + CoffeeTable.
2. Several variants of this family. For example, products Chair + Sofa + CoffeeTable are available in these variants: Modern, Victorian, ArtDeco.

You need a way to create individual furniture objects so that they match other objects of the same family. Customers get quite mad when they receive non-matching furniture.

Also, you don't want to change existing code when adding new products or families of products to the program. Furniture vendors update their catalogs very often, and you wouldn't want to change the core code each time it happens.

### Solution

The first thing the Abstract Factory pattern suggests is to explicitly declare interfaces for each distinct product of the product family (e.g., chair, sofa or coffee table). Then you can make all variants of products follow those interfaces. For example, all chair variants can implement the Chair interface; all coffee table variants can implement the CoffeeTable interface, and so on.

The next move is to declare the _Abstract Factory_--an interface with a list of creation methods for all products that are part of the product family (for example, createChair, createSofa and createCoffeeTable). These methods must return **abstract** product types represented by the interfaces we extracted previously: Chair, Sofa, CoffeeTable and so on.

Now, how about the product variants? For each variant of a product family, we create a separate factory class based on the AbstractFactory interface. A factory is a class that returns products of a particular kind. For example, the ModernFactory can only create ModernChair, ModernSofa and ModernCoffeeTable objects.

The client code has to work with both factories and products via their respective abstract interfaces. This lets you change the type of a factory that you pass to the client code, as well as the product variant that the client code receives, without breaking the actual client code.

The client shouldn't care about the concrete class of the factory it works with.

Say the client wants a factory to produce a chair. The client doesn't have to be aware of the factory's class, nor does it matter what kind of chair it gets. Whether it's a Modern model or a Victorian-style chair, the client must treat all chairs in the same manner, using the abstract Chair interface. With this approach, the only thing that the client knows about the chair is that it implements the sitOn method in some way. Also, whichever variant of the chair is returned, it'll always match the type of sofa or coffee table produced by the same factory object.

One more thing left to clarify: if the client is only exposed to the abstract interfaces, what creates the actual factory objects? Usually, the application creates a concrete factory object at the initialization stage. Just before that, the app must select the factory type depending on the configuration or the environment settings.
Abstract Products declare interfaces for a set of distinct but related products which make up a product family.

Concrete Products are various implementations of abstract products, grouped by variants. Each abstract product (chair/sofa) must be implemented in all given variants (Victorian/Modern).

The **Abstract Factory** interface declares a set of methods for creating each of the abstract products.

Concrete Factories implement creation methods of the abstract factory. Each concrete factory corresponds to a specific variant of products and creates only those product variants.

Although concrete factories instantiate concrete products, signatures of their creation methods must return corresponding _abstract_ products. This way the client code that uses a factory doesn't get coupled to the specific variant of the product it gets from a factory. The **Client** can work with any concrete factory/product variant, as long as it communicates with their objects via abstract interfaces.

## # Pseudocode

This example illustrates how the **Abstract Factory** pattern can be used for creating cross-platform UI elements without coupling the client code to concrete UI classes, while keeping all created elements consistent with a selected operating system.

[MISSING_PAGE_FAIL:95]

[MISSING_PAGE_EMPTY:96]

1//Theabstractfactoryinterfacedeclaresastofmethodsthat2//returndifferentabstractproducts.Theseproductsarecalled3//afamilyandarerelatedbyahigh-levelthemeorconcept.4//Productsofonefamilyareusuallyabletocollaborateamong5//themselves.Afamilyofproductsmayhaveseveralvariants,6//buttheproductsofonevariantareincompatiblewiththe7//productsofanothervariant.8interfaceGUIFactoryis9methodcreateButton():Button10methodcreateCheckbox():Checkbox
11
12
13//Concretefactoriesproduceafamilyofproductsthatbelong14//toasingvariant.Thefactoryguaranteesthatthe15//resultingproductsarecompatible.Signaturesoftheconcrete16//factory'smethodsreturnanabstractproduct,whileinside17//themethodaconcreteproductisinstantiated.18classWinFactoryimplementsGUIFactoryis19methodcreateButton():Buttonis20returnnewWinButton()21methodcreateCheckbox():Checkboxis22returnnewWinCheckbox()23
24//Eachconcretefactoryhasacorrespondingproductvariant.25classMacFactoryimplementsGUIFactoryis26methodcreateButton():Buttonis27returnnewMacButton()28methodcreateCheckbox():Checkboxis29returnnewMacCheckbox()30// Each distinct product of a product family should have a base 34 // interface. All variants of the product must implement this 35 // interface.
36interface Button is 37method paint() 38
39// Concrete products are created by corresponding concrete 40 // factories.
41class WinButton implements Button is 42method paint() is 43// Render a button in Windows style.
44
45class MacButton implements Button is 46method paint() is 47// Render a button in macOS style.
48
49// Here's the base interface of another product. All products 50 // can interact with each other, but proper interaction is 51// possible only between products of the same concrete variant.
52interface Checkbox is 53method paint() 54
55class WinCheckbox implements Checkbox is 56method paint() is 57// Render a checkbox in Windows style.
58
59class MacCheckbox implements Checkbox is 60method paint() is 61// Render a checkbox in macOS style.
62
63// The client code works with factories and products only
66 // through abstract types: GUIFactory, Button and Checkbox. This
67 // lets you pass any factory or product subclass to the client
68 // code without breaking it.
69 class Application is
70 private field button: Button
71 constructor Application(factory: GUIFactory) is
72 this.factory = factory
73 method createUI() is
74 this.button = factory.createButton()
75 method paint() is
76 button.paint()
77
78
79 // The application picks the factory type depending on the
80 // current configuration or environment settings and creates it
81 // at runtime (usually at the initialization stage).
82 class ApplicationConfigurator is
83 method main() is
84 config = readApplicationConfigFile()
85
86 if (config.OS == "Windows") then
87 factory = new WinFactory()
88 else if (config.OS == "Mac") then
89 factory = new MacFactory()
90 else
91 throw new Exception("Error! Unknown operating system.")
92
93 Application app = new Application(factory)

[MISSING_PAGE_EMPTY:100]

Declare abstract product interfaces for all product types. Then make all concrete product classes implement these interfaces.
3. Declare the abstract factory interface with a set of creation methods for all abstract products.
4. Implement a set of concrete factory classes, one for each product variant.
5. Create factory initialization code somewhere in the app. It should instantiate one of the concrete factory classes, depending on the application configuration or the current environment. Pass this factory object to all classes that construct products.
6. Scan through the code and find all direct calls to product constructors. Replace them with calls to the appropriate creation method on the factory object.

### Pros and Cons

You can be sure that the products you're getting from a factory are compatible with each other.

You avoid tight coupling between concrete products and client code.

_Single Responsibility Principle._ You can extract the product creation code into one place, making the code easier to support.

Open/Closed Principle. You can introduce new variants of products without breaking existing client code.
* The code may become more complicated than it should be, since a lot of new interfaces and classes are introduced along with the pattern.
* Relations with Other Patterns
* Many designs start by using **Factory Method** (less complicated and more customizable via subclasses) and evolve toward **Abstract Factory**, **Prototype**, or **Builder** (more flexible, but more complicated).
* **Builder** focuses on constructing complex objects step by step. **Abstract Factory** specializes in creating families of related objects. _Abstract Factory_ returns the product immediately, whereas _Builder_ lets you run some additional construction steps before fetching the product.
* **Abstract Factory** classes are often based on a set of **Factory Methods**, but you can also use **Prototype** to compose the methods on these classes.
* **Abstract Factory** can serve as an alternative to **Facade** when you only want to hide the way the subsystem objects are created from the client code.

You can use **Abstract Factory** along with **Bridge**. This pairing is useful when some abstractions defined by _Bridge_ can only work with specific implementations. In this case, _Abstract Factory_ can encapsulate these relations and hide the complexity from the client code.
* **Abstract Factories**, **Builders** and **Prototypes** can all be implemented as **Singletons**.

**Builder** is a creational design pattern that lets you construct complex objects step by step. The pattern allows you to produce different types and representations of an object using the same construction code.

* [104] Problem
* [105] Imagine a complex object that requires laborious, step-by-step initialization of many fields and nested objects. Such initialization code is usually buried inside a monstrous constructor with lots of parameters. Or even worse: scattered all over the client code.
* [106] _You might make the program too complex by creating a subclass for every possible configuration of an object._

For example, let's think about how to create a House object. To build a simple house, you need to construct four walls and a floor, install a door, fit a pair of windows, and build a roof. But what if you want a bigger, brighter house, with a backyard and other goodies (like a heating system, plumbing, and electrical wiring)?The simplest solution is to extend the base House class and create a set of subclasses to cover all combinations of the parameters. But eventually you'll end up with a considerable number of subclasses. Any new parameter, such as the porch style, will require growing this hierarchy even more.

There's another approach that doesn't involve breeding subclasses. You can create a giant constructor right in the base House class with all possible parameters that control the house object. While this approach indeed eliminates the need for subclasses, it creates another problem.

In most cases most of the parameters will be unused, making **the constructor calls pretty ugly**. For instance, only a fraction of houses have swimming pools, so the parameters related to swimming pools will be useless nine times out of ten.

* 2 Solution
* The Builder pattern suggests that you extract the object construction code out of its own class and move it to separate objects called _builders_.
* 3 The Builder pattern lets you construct complex objects step by step. The Builder doesn't allow other objects to access the product while it's being built.
* The pattern organizes object construction into a set of steps (buildWalls, buildDoor, etc.). To create an object, you execute a series of these steps on a builder object. The important part is that you don't need to call all of the steps. You can call only those steps that are necessary for producing a particular configuration of an object.

Some of the construction steps might require different implementation when you need to build various representations of the product. For example, walls of a cabin may be built of wood, but the castle walls must be built with stone.

In this case, you can create several different builder classes that implement the same set of building steps, but in a different manner. Then you can use these builders in the construction process (i.e., an ordered set of calls to the building steps) to produce different kinds of objects.

For example, imagine a builder that builds everything from wood and glass, a second one that builds everything with stone and iron and a third one that uses gold and diamonds. By calling the same set of steps, you get a regular house from the first builder, a small castle from the second and a palace from the third. However, this would only work if the client code that calls the building steps is able to interact with builders using a common interface.

#### Director

You can go further and extract a series of calls to the builder steps you use to construct a product into a separate class called _director_. The director class defines the order in which to execute the building steps, while the builder provides the implementation for those steps.

Having a director class in your program isn't strictly necessary. You can always call the building steps in a specific order directly from the client code. However, the director class might be a good place to put various construction routines so you can reuse them across your program.

In addition, the director class completely hides the details of product construction from the client code. The client only needs to associate a builder with a director, launch the construction with the director, and get the result from the builder.
1. The **Builder** interface declares product construction steps that are common to all types of builders.
2. **Concrete Builders** provide different implementations of the construction steps. Concrete builders may produce products that don't follow the common interface.
3. **Products** are resulting objects. Products constructed by different builders don't have to belong to the same class hierarchy or interface.
4. The **Director** class defines the order in which to call construction steps, so you can create and reuse specific configurations of products.
5. The **Client** must associate one of the builder objects with the director. Usually, it's done just once, via parameters of the director's constructor. Then the director uses that builder object for all further construction. However, there's an alternative approach for when the client passes the builder object to the production method of the director. In this case, you can use a different builder each time you produce something with the director.

## # Pseudocode

This example of the **Builder** pattern illustrates how you can reuse the same object construction code when building differ ent types of products, such as cars, and create the corresponding manuals for them.

A car is a complex object that can be constructed in a hundred different ways. Instead of bloating the Car class with a huge constructor, we extracted the car assembly code into a separate car builder class. This class has a set of methods for configuring various parts of a car.

If the client code needs to assemble a special, fine-tuned model of a car, it can work with the builder directly. On the other hand, the client can delegate the assembly to the director class, which knows how to use a builder to construct several of the most popular models of cars.

You might be shocked, but every car needs a manual (seriously, who reads them?). The manual describes every feature of the car, so the details in the manuals vary across the different models. That's why it makes sense to reuse an existing construction process for both real cars and their respective manuals. Of course, building a manual isn't the same as building a car, and that's why we must provide another builder class that specializes in composing manuals. This class implements the same building methods as its car-building sibling, but instead of crafting car parts, it describes them. By passing these builders to the same director object, we can construct either a car or a manual.

The final part is fetching the resulting object. A metal car and a paper manual, although related, are still very different things. We can't place a method for fetching results in the director without coupling the director to concrete product classes. Hence, we obtain the result of the construction from the builder which performed the job.

1//Using the Builder pattern makes sense only when your products
2//are quite complex and require extensive configuration. The
3//following two products are related, although they don't have
4//a common interface.
5classCaris
6//AcarcanhaveagGPS,tripcomputerandsomenumberof
7//seats.Differentmodelsofcars(sportscar,SUV,
8//cabriolet)mighthavedifferentfeaturesinstalledor
9//enabled.
10
11classManualis
12//Eachcarshouldhaveausermanualthatcorrespondsto
13//thecar'sconfigurationanddescribesallitsfeatures.
14
15
16//Thebuilderinterfacespecifiesmethodsforcreatingthe
17//differentpartsoftheproductobjects.
18interfaceBuilderis
19methodreset()
20methodsetSeats(...)
21methodsetEngine(...)
22methodsetTripComputer(...)
23methodsetGPS(...)
24
25//Theconcretebuilderclassesfollowthebuilderinterfaceand
26//providespecificimplementationsofthebuildingsteps.Your
27//programmayhaveseveralvariationsofbuilders,each
28//implementeddifferently.
29classCarBuilderimplementsBuilderis
30privatefieldcar:Car
31// A fresh builder instance should contain a blank product
34//object which it uses in further assembly.
35constructor CarBuilder() is
36this.reset()
37
38// The reset method clears the object being built.
39method reset() is
40this.car = new Car()
41
42// All production steps work with the same product instance.
43method setSeats(...) is
44// Set the number of seats in the car.
45
46method setEngine(...) is
47// Install a given engine.
48
49method setTripComputer(...) is
50// Install a trip computer.
51
52method setGPS(...) is
53// Install a global positioning system.
54
55// Concrete builders are supposed to provide their Own
56// methods for retrieving results. That's because various
57// types of builders may create entirely different products
58// that don't all follow the same interface. Therefore such
59// methods can't be declared in the builder interface (at
60// least not in a statically-typed programming language).
61//
62// Usually, after returning the end result to the client, a
63// builder instance is expected to be ready to start
64// producing another product. That's why it's usual //practicetocalltheresetmethodattheendofthe66//'getProduct'methodbody.However,thisbehavioris't67//mandatory,andyoucanmakeyourbuilderwaitforan68//explicitresetcallfromtheclientcodebeforedisposing69//ofthepreviousresult.70methodgetProduct():Caris71product=this.car72this.reset()73returnproduct74
75//Unlikeothercreationalpatterns,builderletsyouconstruct76//unrelatedproductsthatdon'tfollowacommoninterface.77classCarManualBuilderimplementsBuilderis78privatefieldmanual:Manual79
80constructorCarManualBuilder()is81this.reset()82
83methodreset()is84this.manual=newManual()85
86methodsetSeats(...)is87//Documentcarseatfeatures.88
89methodsetEngine(...)is90//Addengineinstructions.91
92methodsetTripComputer(...)is93//Addtripcomputerinstructions.94
95methodsetGPS(...)is96//AddGPSinstructions.

method getProduct():Manual is
98 // Return the manual and reset the builder.
99
100
101 // The director is only responsible for executing the building
102 // steps in a particular sequence. It's helpful when producing
103 // products according to a specific order or configuration.
104 // Strictly speaking, the director class is optional, since the
105 // client can control builders directly.
106 class Director is
107 private field builder:Builder
108
109 // The director works with any builder instance that the
110 // client code passes to it. This way, the client code may
111 // alter the final type of the newly assembled product.
112 method setBuilder(builder:Builder)
113 this.builder = builder
114
115 // The director can construct several product variations
116 // using the same building steps.
117 method constructSportsCar(builder: Builder) is
118 builder.reset()
119 builder.setSeats(2)
120 builder.setEngine(new SportEngine())
121 builder.setTripComputer(true)
122 builder.setGPS(true)
123
124 method constructSUV(builder: Builder) is
125 //...
126
127

[MISSING_PAGE_FAIL:118]

classPizza{
2Pizza(intsize){...}
3Pizza(intsize,booleancheese){...}
4Pizza(intsize,booleancheese,booleanpepperoni){...}
5//...

Creating such a monster is only possible in languages that support

method overloading, such as C#or Java.

The Builder pattern lets you build objects step by step, using only those steps that you really need. After implementing the pattern, you don't have to cram dozens of parameters into your constructors anymore.

Use the Builder pattern when you want your code to be able to create different representations of some product (for example, stone and wooden houses).

The Builder pattern can be applied when construction of various representations of the product involves similar steps that differ only in the details.

The base builder interface defines all possible construction steps, and concrete builders implement these steps to construct particular representations of the product. Meanwhile, the director class guides the order of construction.

Use the Builder to construct Composite trees or other complex objects.

The Builder pattern lets you construct products step-by-step. You could defer execution of some steps without breaking the final product. You can even call steps recursively, which comes in handy when you need to build an object tree.

A builder doesn't expose the unfinished product while running construction steps. This prevents the client code from fetching an incomplete result.

How to Implement

Make sure that you can clearly define the common construction steps for building all available product representations. Otherwise, you won't be able to proceed with implementing the pattern.

Declare these steps in the base builder interface.

Create a concrete builder class for each of the product representations and implement their construction steps.

Don't forget about implementing a method for fetching the result of the construction. The reason why this method can't be declared inside the builder interface is that various builders may construct products that don't have a common interface. Therefore, you don't know what would be the return type for such a method. However, if you're dealing with products from a single hierarchy, the fetching method can be safely added to the base interface.

* 4.Think about creating a director class. It may encapsulate various ways to construct a product using the same builder object.
* 5.The client code creates both the builder and the director objects. Before construction starts, the client must pass a builder object to the director. Usually, the client does this only once, via parameters of the director's constructor. The director uses the builder object in all further construction. There's an alternative approach, where the builder is passed directly to the construction method of the director.
* 6.The construction result can be obtained directly from the director only if all products follow the same interface. Otherwise, the client should fetch the result from the builder.
* 7.Pros and Cons
* 8.You can construct objects step-by-step, defer construction steps or run steps recursively.
* 9.You can reuse the same construction code when building various representations of products.
* 9.Single Responsibility Principle.You can isolate complex construction code from the business logic of the product.
* 10.The overall complexity of the code increases since the pattern requires creating multiple new classes.

Relations with Other Patterns

Many designs start by using **Factory Method** (less complicated and more customizable via subclasses) and evolve toward **Abstract Factory**, **Prototype**, or **Builder** (more flexible, but more complicated).

* **Builder** focuses on constructing complex objects step by step. **Abstract Factory** specializes in creating families of related objects. _Abstract Factory_ returns the product immediately, whereas _Builder_ lets you run some additional construction steps before fetching the product.
* You can use **Builder** when creating complex **Composite** trees because you can program its construction steps to work recursively.
* You can combine **Builder** with **Bridge**: the _director_ class plays the role of the abstraction, while different _builders_ act as _implementations_.
* **Abstract Factories**, **Builders** and **Prototypes** can all be implemented as **Singletons**.

**Prototype** is a creational design pattern that lets you copy existing objects without making your code dependent on their classes.

* 3. Problem Say you have an object, and you want to create an exact copy of it. How would you do it? First, you have to create a new object of the same class. Then you have to go through all the fields of the original object and copy their values over to the new object.
* 4. Nicel But there's a catch. Not all objects can be copied that way because some of the object's fields may be private and not visible from outside of the object itself.
* 5.2 Where's one more problem with the direct approach. Since you have to know the object's class to create a duplicate, your code becomes dependent on that class. If the extra dependency doesn't scare you, there's another catch. Sometimes you only know the interface that the object follows, but not its concrete class, when, for example, a parameter in a method accepts any objects that follow some interface.

## 2 Solution

The Prototype pattern delegates the cloning process to the actual objects that are being cloned. The pattern declares a common interface for all objects that support cloning. This interface lets you clone an object without coupling your code to the class of that object. Usually, such an interface contains just a single clone method.

The implementation of the clone method is very similar in all classes. The method creates an object of the current class and carries over all of the field values of the old object into the new one. You can even copy private fields because most programming languages let objects access private fields of other objects that belong to the same class.

An object that supports cloning is called a _prototype_. When your objects have dozens of fields and hundreds of possible configurations, cloning them might serve as an alternative to subclassing.

Here's how it works: you create a set of objects, configured in various ways. When you need an object like the one you've configured, you just clone a prototype instead of constructing a new object from scratch.

### Real-World Analogy

In real life, prototypes are used for performing various tests before starting mass production of a product. However, in this case, prototypes don't participate in any actual production, playing a passive role instead.

Since industrial prototypes don't really copy themselves, a much closer analogy to the pattern is the process of mitotic cell division (biology, remember?). After mitotic division, a pair of identical cells is formed. The original cell acts as a prototype and takes an active role in creating the copy.

### Structure

1. The **Prototype** interface declares the cloning methods. In most cases, it's a single clone method.

2. The Concrete Prototype class implements the cloning method. In addition to copying the original object's data to the clone, this method may also handle some edge cases of the cloning process related to cloning linked objects, untangling recursive dependencies, etc.
3. The Client can produce a copy of any object that follows the prototype interface.

Prototype registry implementation

Figure 12: The Concrete Prototype class implements the cloning method. In addition to copying the original object’s data to the clone, this method may also handle some edge cases of the cloning process related to cloning linked objects, untangling recursive dependencies, etc.

1. The **Prototype Registry** provides an easy way to access frequently-used prototypes. It stores a set of pre-built objects that are ready to be copied. The simplest prototype registry is a name - prototype hash map. However, if you need better search criteria than a simple name, you can build a much more robust version of the registry.

## # Pseudocode

In this example, the **Prototype** pattern lets you produce exact copies of geometric objects, without coupling the code to their classes.

All shape classes follow the same interface, which provides a cloning method. A subclass may call the parent's cloning

[MISSING_PAGE_EMPTY:130]

[MISSING_PAGE_EMPTY:131]

circle.Y = 10
62 circle.radius = 20
63 shapes.add(circle)
64
65 Circle anotherCircle = circle.clone()
66 shapes.add(anotherCircle)
67 // The 'anotherCircle' variable contains an exact copy
68 // of the 'circle' object.
69
70 Rectangle rectangle = new Rectangle()
71 rectangle.width = 10
72 rectangle.height = 20
73 shapes.add(rectangle)
74
75 method businessLogic() is
76 // Prototype rocks because it lets you produce a copy of
77 // an object without knowing anything about its type.
78 Array shapesCopy = new Array of Shapes.
79
80 // For instance, we don't know the exact elements in the
81 // shapes array. All we know is that they are all
82 // shapes. But thanks to polymorphism, when we call the
83 // 'clone' method on a shape the program checks its real
84 // class and runs the appropriate clone method defined
85 // in that class. That's why we get proper clones
86 // instead of a set of simple Shape objects.
87 foreach (s in shapes) do
88 shapesCopy.add(s.clone())
89
80 // The'shapesCopy' array contains exact copies of the
91 //'shape' array's children.

[MISSING_PAGE_EMPTY:133]

## 11 How to Implement

1. Create the prototype interface and declare the clone method in it. Or just add the method to all classes of an existing class hierarchy, if you have one.
2. A prototype class must define the alternative constructor that accepts an object of that class as an argument. The constructor must copy the values of all fields defined in the class from the passed object into the newly created instance. If you're changing a subclass, you must call the parent constructor to let the superclass handle the cloning of its private fields. If your programming language doesn't support method overloading, you may define a special method for copying the object data. The constructor is a more convenient place to do this because it delivers the resulting object right after you call the new operator.
3. The cloning method usually consists of just one line: running a new operator with the prototypical version of the constructor. Note, that every class must explicitly override the cloning method and use its own class name along with the new operator. Otherwise, the cloning method may produce an object of a parent class.
4. Optionally, create a centralized prototype registry to store a catalog of frequently used prototypes.

You can implement the registry as a new factory class or put it in the base prototype class with a static method for fetching the prototype. This method should search for a prototype based on search criteria that the client code passes to the method. The criteria might either be a simple string tag or a complex set of search parameters. After the appropriate prototype is found, the registry should clone it and return the copy to the client.

Finally, replace the direct calls to the subclasses' constructors with calls to the factory method of the prototype registry.

### Pros and Cons

You can clone objects without coupling to their concrete classes.

You can get rid of repeated initialization code in favor of cloning pre-built prototypes.

You can produce complex objects more conveniently.

You get an alternative to inheritance when dealing with configuration presets for complex objects.
Relations with Other Patterns

Many designs start by using **Factory Method** (less complicated and more customizable via subclasses) and evolve toward **Abstract Factory**, **Prototype**, or **Builder** (more flexible, but more complicated).

**Abstract Factory** classes are often based on a set of **Factory Methods**, but you can also use **Prototype** to compose the methods on these classes.

**Prototype** can help when you need to save copies of **Commands** into history.

Designs that make heavy use of **Composite** and **Decorator** can often benefit from using **Prototype**. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.

**Prototype** isn't based on inheritance, so it doesn't have its drawbacks. On the other hand, _Prototype_ requires a complicated initialization of the cloned object. **Factory Method** is based on inheritance but doesn't require an initialization step.

Sometimes **Prototype** can be a simpler alternative to **Memen-to**. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn't have links to external resources, or the links are easy to re-establish.

**Abstract Factories**, **Builders** and **Prototypes** can all be implemented as **Singletons**.

**Singleton** is a creational design pattern that lets you ensure that a class has only one instance, while providing a global access point to this instance.

## Chapter 3 Problem

The Singleton pattern solves two problems at the same time, violating the _Single Responsibility Principle_:

1. **Ensure that a class has just a single instance**. Why would anyone want to control how many instances a class has? The most common reason for this is to control access to some shared resource\(-\)for example, a database or a file. Here's how it works: imagine that you created an object, but after a while decided to create a new one. Instead of receiving a fresh object, you'll get the one you already created. Note that this behavior is impossible to implement with a regular constructor since a constructor call **must** always return a new object by design.

## Chapter 2 **Provide a global access point to that instance**

Remember those global variables that you (all right, me) used to store some essential objects? While they're very handy, they're also very unsafe since any code can potentially overwrite the contents of those variables and crash the app.

Just like a global variable, the Singleton pattern lets you access some object from anywhere in the program. However, it also protects that instance from being overwritten by other code.

There's another side to this problem: you don't want the code that solves problem #1 to be scattered all over your program. It's much better to have it within one class, especially if the rest of your code already depends on it.

Nowadays, the Singleton pattern has become so popular that people may call something a _singleton_ even if it solves just one of the listed problems.

### 2. Solution

All implementations of the Singleton have these two steps in common:

* Make the default constructor private, to prevent other objects from using the new operator with the Singleton class.
* Create a static creation method that acts as a constructor. Under the hood, this method calls the private constructor tocreate an object and saves it in a static field. All following calls to this method return the cached object.

If your code has access to the Singleton class, then it's able to call the Singleton's static method. So whenever that method is called, the same object is always returned.

### Real-World Analogy

The government is an excellent example of the Singleton pattern. A country can have only one official government. Regardless of the personal identities of the individuals who form governments, the title, "The Government of X", is a global point of access that identifies the group of people in charge.
The **Singleton** class declares the static method getInstance that returns the same instance of its own class.

The Singleton's constructor should be hidden from the client code. Calling the getInstance method should be the only way of getting the Singleton object.

## # Pseudocode

In this example, the database connection class acts as a Singleton.

This class doesn't have a public constructor, so the only way to get its object is to call the getInstance method. This method caches the first created object and returns it in all subsequent calls.

1 // The Database class defines the 'getInstance' method that lets 2 // clients access the same instance of a database connection 3 // throughout the program.
4 class Database is
5 // The field for storing the singleton instance should be
6 // declared static.
7 private static field instance: Database
8
9 // The singleton's constructor should always be private to
10 // prevent direct construction calls with the 'new'
11 // operator.
12 private constructor Database() is 

[MISSING_PAGE_FAIL:142]

[MISSING_PAGE_EMPTY:143]

## 5 How to Implement

1. Add a private static field to the class for storing the singleton instance.
2. Declare a public static creation method for getting the singleton instance.
3. Implement "lazy initialization" inside the static method. It should create a new object on its first call and put it into the static field. The method should always return that instance on all subsequent calls.
4. Make the constructor of the class private. The static method of the class will still be able to call the constructor, but not the other objects.
5. Go over the client code and replace all direct calls to the singleton's constructor with calls to its static creation method.

### Pros and Cons

You can be sure that a class has only a single instance.

You gain a global access point to that instance.

The singleton object is initialized only when it's requested for the first time.

* Violates the _Single Responsibility Principle_. The pattern solves two problems at the time.

* [144] The Singleton pattern can mask bad design, for instance, when the components of the program know too much about each other.
* [145] The pattern requires special treatment in a multithreaded environment so that multiple threads won't create a singleton object several times.
* [146] It may be difficult to unit test the client code of the Singleton because many test frameworks rely on inheritance when producing mock objects. Since the constructor of the singleton class is private and overriding static methods is impossible in most languages, you will need to think of a creative way to mock the singleton. Or just don't write the tests. Or don't use the Singleton pattern.
* [147] Relations with Other Patterns
* [148] A **Facade** class can often be transformed into a **Singleton** since a single facade object is sufficient in most cases.
* [149] **Flyweight** would resemble **Singleton** if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:

1. There should be only one Singleton instance, whereas a _Flyweight_ class can have multiple instances with different intrinsic states.

* [2] The _Singleton_ object can be mutable. Flyweight objects are immutable.
* [3]**Abstract Factories**, **Builders** and **Prototypes** can all be implemented as **Singletons**.

Structural Design Patterns

Structural patterns explain how to assemble objects and classes into larger structures, while keeping this structures flexible and efficient.

Provides a unified interface that allows objects with incompatible interfaces to collaborate.

Lets you split a large class or a set of closely related classes into two separate hierarchies\(-\)abstraction and implementation\(-\)which can be developed independently of each other.

[MISSING_PAGE_EMPTY:148]

[MISSING_PAGE_EMPTY:149]

**Adapter** is a structural design pattern that allows objects with incompatible interfaces to collaborate.

[MISSING_PAGE_EMPTY:151]

* 2 Solution

You can create an _adapter_. This is a special object that converts the interface of one object so that another object can understand it.

An adapter wraps one of the objects to hide the complexity of conversion happening behind the scenes. The wrapped object isn't even aware of the adapter. For example, you can wrap an object that operates in meters and kilometers with an adapter that converts all of the data to imperial units such as feet and miles.

Adapters can not only convert data into various formats but can also help objects with different interfaces collaborate. Here's how it works:

1. The adapter gets an interface, compatible with one of the existing objects.
2. Using this interface, the existing object can safely call the adapter's methods.
3. Upon receiving a call, the adapter passes the request to the second object, but in a format and order that the second object expects.

Sometimes it's even possible to create a two-way adapter that can convert the calls in both directions.

[MISSING_PAGE_EMPTY:153]

That's why your US plug won't fit a German socket. The problem can be solved by using a power plug adapter that has the American-style socket and the European-style plug.

## 9 Structure

### Object adapter

This implementation uses the composition principle: the adapter implements the interface of one object and wraps the other one. It can be implemented in all popular programming languages.

1. The **Client** is a class that contains the existing business logic of the program.
2. The **Client Interface** describes a protocol that other classes must follow to be able to collaborate with the client code.
3. The **Service** is some useful class (usually 3rd-party or legacy). The client can't use this class directly because it has an incompatible interface.
4. The **Adapter** is a class that's able to work with both the client and the service: it implements the client interface, while wrapping the service object. The adapter receives calls from the client via the adapter interface and translates them into calls to the wrapped service object in a format it can understand.
5. The client code doesn't get coupled to the concrete adapter class as long as it works with the adapter via the client inter face. Thanks to this, you can introduce new types of adapters into the program without breaking the existing client code. This can be useful when the interface of the service class gets changed or replaced: you can just create a new adapter class without changing the client code.

## Class adapter

This implementation uses inheritance: the adapter inherits interfaces from both objects at the same time. Note that this approach can only be implemented in programming languages that support multiple inheritance, such as C++.

1. The **Class Adapter** doesn't need to wrap any objects because it inherits behaviors from both the client and the service. The adaptation happens within the overridden methods. The resulting adapter can be used in place of an existing client class.

## Chapter 4 Pseudocode

This example of the **Adapter** pattern is based on the classic conflict between square pegs and round holes.

The Adapter pretends to be a round peg, with a radius equal to a half of the square's diameter (in other words, the radius of the smallest circle that can accommodate the square peg).

1 // Say you have two classes with compatible interfaces:
2 // RoundHole and RoundPeg.
3 **class RoundHole is**
4 **constructor RoundHole(radius) {... }
5
6 **method** getRadius() **is**
7 // Return the radius of the hole.

method fits(peg: RoundPeg) is
10return this.getRadius() >= peg.radius()
11
12class RoundPeg is
13constructor RoundPeg(radius) {... }
14
15method getRadius() is
16// Return the radius of the peg.
17
18
19// But there's an incompatible class: SquarePeg.
20class SquarePeg is
21constructor SquarePeg(width) {... }
22
23method getWidth() is
24// Return the square peg width.
25
26
27// An adapter class lets you fit square pegs into round holes.
28// It extends the RoundPeg class to let the adapter objects act
29// as round pegs.
30class SquarePegAdapter extends RoundPeg is
31// In reality, the adapter contains an instance of the
32// SquarePeg class.
33private field peg: SquarePeg
34
35constructor SquarePegAdapter(peg: SquarePeg) is
36this.peg = peg
37
38method getRadius() is
39// The adapter pretends that it's a round peg with a * [40] // radius that could fit the square peg that the adapter
* [41] // actually wraps.
* [42] **return*
* Math.sqrt(2) / 2
* [43]
* [44]
* [45] // Somewhere in client code.
* [46] hole = **new** RoundHole(5)
* [47] rpeg = **new** RoundPeg(5)
* [48] hole.fits(rpeg) // true
* [49]
* [50] small_sqpeg = **new** SquarePeg(5)
* [51] large_sqpeg = **new** SquarePeg(10)
* [52] hole.fits(small_sqpeg) // this won't compile (incompatible types)
* [53]
* [54] small_sqpeg_adapter = **new** SquarePegAdapter(small_sqpeg)
* [55] large_sqpeg_adapter = **new** SquarePegAdapter(large_sqpeg)
* [56] hole.fits(small_sqpeg_adapter) // true
* [57] hole.fits(large_sqpeg_adapter) // false

### Applicability

* [58] Use the Adapter class when you want to use some existing class, but its interface isn't compatible with the rest of your code.
* [59] The Adapter pattern lets you create a middle-layer class that serves as a translator between your code and a legacy class, a 3rd-party class or any other class with a weird interface.

**Use the pattern when you want to reuse several existing subclasses that lack some common functionality that can't be added to the superclass.**

**You could extend each subclass and put the missing functionality into new child classes. However, you'll need to duplicate the code across all of these new classes, which **smells really bad**.

The much more elegant solution would be to put the missing functionality into an adapter class. Then you would wrap objects with missing features inside the adapter, gaining needed features dynamically. For this to work, the target classes must have a common interface, and the adapter's field should follow that interface. This approach looks very similar to the **Decorator** pattern.

**How to Implement**

1. Make sure that you have at least two classes with incompatible interfaces: * A useful _service_ class, which you can't change (often 3rd-party, legacy or with lots of existing dependencies). * One or several _client_ classes that would benefit from using the service class.
2. Declare the client interface and describe how clients communicate with the service.

Create the adapter class and make it follow the client interface. Leave all the methods empty for now.
4. Add a field to the adapter class to store a reference to the service object. The common practice is to initialize this field via the constructor, but sometimes it's more convenient to pass it to the adapter when calling its methods.
5. One by one, implement all methods of the client interface in the adapter class. The adapter should delegate most of the real work to the service object, handling only the interface or data format conversion.
6. Clients should use the adapter via the client interface. This will let you change or extend the adapters without affecting the client code.

### _Single Responsibility Principle_

You can separate the interface or data conversion code from the primary business logic of the program.

_Open/Closed Principle_

You can introduce new types of adapters into the program without breaking the existing client code, as long as they work with the adapters through the client interface.

* The overall complexity of the code increases because you need to introduce a set of new interfaces and classes. Sometimes it'ssimpler just to change the service class so that it matches the rest of your code.

## Relations with Other Patterns

**Bridge** is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, **Adapter** is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.

**Adapter** changes the interface of an existing object, while **Decorator** enhances an object without changing its interface. In addition, _Decorator_ supports recursive composition, which isn't possible when you use _Adapter_.

**Adapter** provides a different interface to the wrapped object, **Proxy** provides it with the same interface, and **Decorator** provides it with an enhanced interface.

**Facade** defines a new interface for existing objects, whereas **Adapter** tries to make the existing interface usable. _Adapter_ usually wraps just one object, while _Facade_ works with an entire subsystem of objects.

**Bridge**, **State**, **Strategy** (and to some degree **Adapter**) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn't just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.

**Bridge** is a structural design pattern that lets you split a large class or a set of closely related classes into two separate hierarchies\(-\)abstraction and implementation\(-\)which can be developed independently of each other.

Problem

_Abstraction? Implementation?_ Sound scary? Stay calm and let's consider a simple example.

Say you have a geometric Shape class with a pair of subclasses: Circle and Square. You want to extend this class hierarchy to incorporate colors, so you plan to create Red and Blue shape subclasses. However, since you already have two subclasses, you'll need to create four class combinations such as BlueCircle and RedSquare.

Adding new shape types and colors to the hierarchy will grow it exponentially. For example, to add a triangle shape you'd

[MISSING_PAGE_EMPTY:165]

Following this approach, we can extract the color-related code into its own class with two subclasses: Red and Blue. The Shape class then gets a reference field pointing to one of the color objects. Now the shape can delegate any color-related work to the linked color object. That reference will act as a bridge between the Shape and Color classes. From now on, adding new colors won't require changing the shape hierarchy, and vice versa.

## Abstraction and Implementation

The GoF book1 introduces the terms _Abstraction_ and _Implementation_ as part of the Bridge definition. In my opinion, the terms sound too academic and make the pattern seem more complicated than it really is. Having read the simple example with shapes and colors, let's decipher the meaning behind the GoF book's scary words.

_Abstraction_ (also called _interface_) is a high-level control layer for some entity. This layer isn't supposed to do any real work on its own. It should delegate the work to the _implementation_ layer (also called _platform_).

Note that we're not talking about _interfaces_ or _abstract classes_ from your programming language. These aren't the same things.

1. "Gang of Four" is a nickname given to the four authors of the original book about design patterns: _Design Patterns: Elements of Reusable Object-Oriented Software_[https://refactoring.guru/gof-book](https://refactoring.guru/gof-book).

When talking about real applications, the abstraction can be represented by a graphical user interface (GUI), and the implementation could be the underlying operating system code (API) which the GUI layer calls in response to user interactions.

Generally speaking, you can extend such an app in two independent directions:

* Have several different GUs (for instance, tailored for regular customers or admins).
* Support several different APIs (for example, to be able to launch the app under Windows, Linux, and MacOS).

In a worst-case scenario, this app might look like a giant spaghetti bowl, where hundreds of conditionals connect different types of GUI with various APIs all over the code.

_Making even a simple change to a monolithic codebase is pretty hard because you must understand the entire thing very well. Making changes to smaller, well-defined modules is much easier._You can bring order to this chaos by extracting the code related to specific interface-platform combinations into separate classes. However, soon you'll discover that there are _lots_ of these classes. The class hierarchy will grow exponentially because adding a new GUI or supporting a different API would require creating more and more classes.

Let's try to solve this issue with the Bridge pattern. It suggests that we divide the classes into two hierarchies:

* Abstraction: the GUI layer of the app.
* Implementation: the operating systems' APIs.

The abstraction object controls the appearance of the app, delegating the actual work to the linked implementation object. Different implementations are interchangeable as long as they follow a common interface, enabling the same GUI to work under Windows and Linux. As a result, you can change the GUI classes without touching the API-related classes. Moreover, adding support for another operating system only requires creating a subclass in the implementation hierarchy.

### Structure

1. The **Abstraction** provides high-level control logic. It relies on the implementation object to do the actual low-level work.
2. The **Implementation** declares the interface that's common for all concrete implementations. An abstraction can only communicate with an implementation object via methods that are declared here. The abstraction may list the same methods as the implementation, but usually the abstraction declares some complex behaviors that rely on a wide variety of primitive operations declared by the implementation.
3. **Concrete Implementations** contain platform-specific code.
4. **Refined Abstractions** provide variants of control logic. Like their parent, they work with different implementations via the general implementation interface.
5. Usually, the **Client** is only interested in working with the abstraction. However, it's the client's job to link the abstraction object with one of the implementation objects.

## # Pseudocode

This example illustrates how the **Bridge** pattern can help divide the monolithic code of an app that manages devices and their remote controls. The Device classes act as the implementation, whereas the Remote s act as the abstraction. The base remote control class declares a reference field that links it with a device object. All remotes work with the devices via the general device interface, which lets the same remote support multiple device types.

You can develop the remote control classes independently from the device classes. All that's needed is to create a new remote subclass. For example, a basic remote control might only have two buttons, but you could extend it with additional features, such as an extra battery or a touchscreen.

The client code links the desired type of remote control with a specific device object via the remote's constructor.

[MISSING_PAGE_EMPTY:172]

[MISSING_PAGE_EMPTY:173]

[MISSING_PAGE_EMPTY:174]

Although it's optional, the Bridge pattern lets you replace the implementation object inside the abstraction. It's as easy as assigning a new value to a field. _By the way, this last item is the main reason why so many people confuse the Bridge with the Strategy pattern. Remember that a pattern is more than just a certain way to structure your classes. It may also communicate intent and a problem being addressed._

## 11 How to Implement

1. Identify the orthogonal dimensions in your classes. These independent concepts could be: abstraction/platform, domain/infrastructure, front-end/back-end, or interface/implementation.
2. See what operations the client needs and define them in the base abstraction class.
3. Determine the operations available on all platforms. Declare the ones that the abstraction needs in the general implementation interface.
4. For all platforms in your domain create concrete implementation classes, but make sure they all follow the implementation interface.
5. Inside the abstraction class, add a reference field for the implementation type. The abstraction delegates most of the work to the implementation object that's referenced in that field.
6. If you have several variants of high-level logic, create refined abstractions for each variant by extending the base abstraction class.
7. The client code should pass an implementation object to the abstraction's constructor to associate one with the other. After that, the client can forget about the implementation and work only with the abstraction object.

### Pros and Cons

You can create platform-independent classes and apps.

The client code works with high-level abstractions. It isn't exposed to the platform details.

_Open/Closed Principle._ You can introduce new abstractions and implementations independently from each other.

_Single Responsibility Principle._ You can focus on high-level logic in the abstraction and on platform details in the implementation.

You might make the code more complicated by applying the pattern to a highly cohesive class.

Relations with Other Patterns
* **Bridge** is usually designed up-front, letting you develop parts of an application independently of each other. On the other hand, **Adapter** is commonly used with an existing app to make some otherwise-incompatible classes work together nicely.
* **Bridge**, **State**, **Strategy** (and to some degree **Adapter**) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn't just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.
* You can use **Abstract Factory** along with **Bridge**. This pairing is useful when some abstractions defined by _Bridge_ can only work with specific implementations. In this case, _Abstract Factory_ can encapsulate these relations and hide the complexity from the client code.
* You can combine **Builder** with **Bridge**: the _director_ class plays the role of the abstraction, while different _builders_ act as _implementations_.

[MISSING_PAGE_EMPTY:178]

* 5. Problem Using the Composite pattern makes sense only when the core model of your app can be represented as a tree. For example, imagine that you have two types of objects: Products and Boxes. A Box can contain several Products as well as a number of smaller Boxes. These little Boxes can also hold some Products or even smaller Boxes, and so on. _An order might comprise various products, packaged in boxes, which are packaged in bigger boxes and so on. The whole structure looks like an upside down tree._Say you decide to create an ordering system that uses these classes. Orders could contain simple products without any wrapping, as well as boxes stuffed with products...and other boxes. How would you determine the total price of such an order?

You could try the direct approach: unwrap all the boxes, go over all the products and then calculate the total. That would be doable in the real world; but in a program, it's not as simple as running a loop. You have to know the classes of Products and Boxes you're going through, the nesting level of the boxes and other nasty details beforehand. All of this makes the direct approach either too awkward or even impossible.

### Solution

The Composite pattern suggests that you work with Products and Boxes through a common interface which declares a method for calculating the total price.

How would this method work? For a product, it'd simply return the product's price. For a box, it'd go over each item the box contains, ask its price and then return a total for this box. If one of these items were a smaller box, that box would also start going over its contents and so on, until the prices of all inner components were calculated. A box could even add some extra cost to the final price, such as packaging cost.

The greatest benefit of this approach is that you don't need to care about the concrete classes of objects that compose the tree. You don't need to know whether an object is a simple product or a sophisticated box. You can treat them all the same via the common interface. When you call a method, the objects themselves pass the request down the tree.

Real-World AnalogyArmies of most countries are structured as hierarchies. An army consists of several divisions; a division is a set of brigades, and a brigade consists of platoons, which can be broken down into squads. Finally, a squad is a small group of real soldiers. Orders are given at the top of the hierarchy and passed down onto each level until every soldier knows what needs to be done.
1. The **Component** interface describes operations that are common to both simple and complex elements of the tree.
2. The **Leaf** is a basic element of a tree that doesn't have sub-elements. Usually, leaf components end up doing most of the real work, since they don't have anyone to delegate the work to.
3. The **Container** (aka _composite_) is an element that has sub-elements: leaves or other containers. A container doesn't know the concrete classes of its children. It works with all sub-elements only via the component interface. Upon receiving a request, a container delegates the work to its sub-elements, processes intermediate results and then returns the final result to the client.
4. The **Client** works with all elements through the component interface. As a result, the client can work in the same way with both simple or complex elements of the tree.

## # Pseudocode

In this example, the **Composite** pattern lets you implement stacking of geometric shapes in a graphical editor.

The CompoundGraphic class is a container that can comprise any number of sub-shapes, including other compound shapes. A compound shape has the same methods as a simple shape. However, instead of doing something on its own, a compound shape passes the request recursively to all its children and "sums up" the result.

The client code works with all shapes through the single interface common to all shape classes. Thus, the client doesn't

[MISSING_PAGE_EMPTY:185]

[MISSING_PAGE_EMPTY:186]

[MISSING_PAGE_FAIL:187]

[MISSING_PAGE_EMPTY:188]

containers, so make sure it's declared with the component interface type.

While implementing the methods of the component interface, remember that a container is supposed to be delegating most of the work to sub-elements.
5. Finally, define the methods for adding and removal of child elements in the container. Keep in mind that these operations can be declared in the component interface. This would violate the _Interface Segregation Principle_ because the methods will be empty in the leaf class. However, the client will be able to treat all the elements equally, even when composing the tree.

### Pros and Cons

You can work with complex tree structures more conveniently: use polymorphism and recursion to your advantage.
* _Open/Closed Principle._ You can introduce new element types into the app without breaking the existing code, which now works with the object tree.
* It might be difficult to provide a common interface for classes whose functionality differs too much. In certain scenarios, you'd need to overgeneralize the component interface, making it harder to comprehend.

Relations with Other Patterns

You can use **Builder** when creating complex **Composite** trees because you can program its construction steps to work recursively.

* **Chain of Responsibility** is often used in conjunction with **Composite**. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.
* You can use **Iterators** to traverse **Composite** trees.
* You can use **Visitor** to execute an operation over an entire **Composite** tree.
* You can implement shared leaf nodes of the **Composite** tree as **Flyweights** to save some RAM.
* **Composite** and **Decorator** have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects.

A _Decorator_ is like a _Composite_ but only has one child component. There's another significant difference: _Decorator_ adds additional responsibilities to the wrapped object, while _Composite_ just "sums up" its children's results.

However, the patterns can also cooperate: you can use _Decorator_ to extend the behavior of a specific object in the _Composite_ tree.
* Designs that make heavy use of **Composite** and **Decorator** can often benefit from using **Prototype**. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.

**Decorator** is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.

* 5. Problem
* 6. Imagine that you're working on a notification library which lets other programs notify their users about important events.
* 7. The initial version of the library was based on the Notifier class that had only a few fields, a constructor and a single send method. The method could accept a message argument from a client and send the message to a list of emails that were passed to the notificator via its constructor. A third-party app which acted as a client was supposed to create and configure the notificator object once, and then use it each time something important happened.
* 8. At some point, you realize that users of the library expect more than just email notifications. Many of them would like to receive an SMS about critical issues. Others would like to be notified on Facebook and, of course, the corporate users would love to get Slack notifications.

How hard can that be? You extended the Notifier class and put the additional notification methods into new subclasses. Now the client was supposed to instantiate the desired notification class and use it for all further notifications.

But then someone reasonably asked you, "Why can't you use several notification types at once? If your house is on fire, you'd probably want to be informed through every channel."

You tried to address that problem by creating special subclasses which combined several notification methods within one class. However, it quickly became apparent that this approach would bloat the code immensely, not only the library code but the client code as well.

You have to find some other way to structure notifications classes so that their number won't accidentally break some Guinness record.

### 2 Solution

Extending a class is the first thing that comes to mind when you need to alter an object's behavior. However, inheritance has several serious caveats that you need to be aware of.

* Inheritance is static. You can't alter the behavior of an existing object at runtime. You can only replace the whole object with another one that's created from a different subclass.
* Subclasses can have just one parent class. In most languages, inheritance doesn't let a class inherit behaviors of multiple classes at the same time.

One of the ways to overcome these caveats is by using _Composition_ instead of _Inheritance_. With composition one object _has a_ reference to another and delegates it some work, whereas with inheritance, the object itself _is_ able to do that work, inheriting the behavior from its superclass.

With composition, you can easily substitute the linked "helper" object with another, changing the behavior of the container at runtime. An object can use the behavior of various classes, having references to multiple objects and delegating them all kinds of work. Composition is the key principle behind many design patterns, including the Decorator. On that note, let's return to the pattern discussion. _Wrapper_ is the alternative nickname for the Decorator pattern that clearly expresses the main idea of the pattern. A "wrapper" is an object that can be linked with some "target" object. The wrapper contains the same set of methods as the target and delegates to it all requests it receives. However, the wrapper may alter the result by doing something either before or after it passes the request to the target. When does a simple wrapper become the real decorator? As I mentioned, the wrapper implements the same interface as the wrapped object. That's why from the client's perspective these objects are identical. Make the wrapper's reference field accept any object that follows that interface. This will let you cover an object in multiple wrappers, adding the combined behavior of all the wrappers to it.

In our notifications example, let's leave the simple email notification behavior inside the base Notifier class, but turn all other notification methods into decorators. The client code would need to wrap a basic notifier object into a set of decorators that match the client's preferences. The resulting objects will be structured as a stack.

The last decorator in the stack would be the object that the client actually works with. Since all decorators implement the same interface as the base notifier, the rest of the client code won't care whether it works with the "pure" notificator object or the decorated one.

We could apply the same approach to other behaviors such as formatting messages or composing the recipient list. The client can decorate the object with any custom decorators, as long as they follow the same interface as the others.

Wearing clothes is an example of using decorators. When you're cold, you wrap yourself in a sweater. If you're still cold with a sweater, you can wear a jacket on top. If it's raining, you can put on a raincoat. All of these garments "extend" your basic behavior but aren't part of you, and you can easily take off any piece of clothing whenever you don't need it.

1. The **Component** declares the common interface for both wrappers and wrapped objects.

[MISSING_PAGE_EMPTY:200]

The application wraps the data source object with a pair of decorators. Both wrappers change the way the data is written to and read from the disk:

* Just before the data is **written to disk**, the decorators encrypt and compress it. The original class writes the encrypted and protected data to the file without knowing about the change.

Right after the data is **read from disk**, it goes through the same decorators, which decompress and decode it.

The decorators and the data source class implement the same interface, which makes them all interchangeable in the client code.

```
1//Thecomponentinterfacedefinesoperationsthatcanbe
2//alteredbydecorators.
3interfaceDataSourceis
4methodwriteData(data)
5methodreadData():data
6
7//Concretecomponentsprovidedefaultimplementationsforthe
8//operations.Theremightbeseveralvariationsofthese
9//classesinaprogram.
10classFileDataSourceimplementsDataSourceis
11constructorFileDataSource(filename){....}
12
13methodwriteData(data)is
14//Writedatatofile.
15
16methodreadData():datais
17//Readdatafromfile.
18
19//Thebasedecoratorclassfollowsthesameinterfaceasthe
20//othercomponents.Theprimarypurposeofthisclassistot
21//definewrappinginterfaceforallconcretedecorators.
22//Thedefaultimplementationofthewrappingcodemightinclude
23//afieldforstoringawrappedcomponentandthemeansto
24//initializeit.

class DataSourceDecorator implements DataSource is
26 protected field wrappee: DataSource
27
28 constructor DataSourceDecorator(source: DataSource) is
29 wrappee = source
30
31 // The base decorator simply delegates all work to the
32 // wrapped component. Extra behaviors can be added in
33 // concrete decorators.
34 method writeData(data) is
35 wrappee.writeData(data)
36
37 // Concrete decorators may call the parent implementation of
38 // the operation instead of calling the wrapped object
39 // directly. This approach simplifies extension of decorator
40 // classes.
41 method readData():data is
42 return wrappee.readData()
43
44 // Concrete decorators must call methods on the wrapped object,
45 // but may add something of their own to the result. Decorators
46 // can execute the added behavior either before or after the
47 // call to a wrapped object.
48 class EncryptionDecorator extends DataSourceDecorator is
49 method writeData(data) is
50 // 1. Encrypt passed data.
51 // 2. Pass encrypted data to the wrappee's writeData
52 // method.
53 method readData():data is
54 // 1. Get data from the wrappee's readData method.
55 // 2. Try to decrypt it if it's encrypted.
56 // 3. Return the result.

//You can wrap objects in several layers of decorators.
58class CompressionDecorator extends DataSourceDecorator is
59method writeData(data)is
60//1. Compress passed data.
61//2. Pass compressed data to the wrapper's writeData
62//method.
63
64method readData():datais
65//1. Get data from the wrappee's readData method.
66//2. Try to decompress it if it's compressed.
67//3. Return the result.
68
69
70//Option1. A simple example of a decorator assembly.
71class Application is
72method dumbUsageExample()is
73source = new FileDataSource("somefile.dat")
74source.writeData(salaryRecords)
75//The target file has been written with plain data.
76
77source = new CompressionDecorator(source)
78source.writeData(salaryRecords)
79//The target file has been written with compressed
80//data.
81
82source = new EncryptionDecorator(source)
83//The source variable now contains this:
84//Encryption > Compression > FileDataSource
85source.writeData(salaryRecords)
86//The file has been written with compressed and
87//encrypted data.

[MISSING_PAGE_EMPTY:205]

* [1] **Use the Decorator pattern when you need to be able to assign extra behaviors to objects at runtime without breaking the code that uses these objects.**
* [2] **The Decorator lets you structure your business logic into layers, create a decorator for each layer and compose objects with various combinations of this logic at runtime. The client code can treat all these objects in the same way, since they all follow a common interface.**
* [3] **Use the pattern when it's awkward or not possible to extend an object's behavior using inheritance.**
* [4] **Many programming languages have the final keyword that can be used to prevent further extension of a class. For a final class, the only way to reuse the existing behavior would be to wrap the class with your own wrapper, using the Decorator pattern.**
* [5] **How to Implement**
* [6] **Make sure your business domain can be represented as a primary component with multiple optional layers over it.**
* [7] **Figure out what methods are common to both the primary component and the optional layers. Create a component interface and declare those methods there.**Create a concrete component class and define the base behavior in it.
4. Create a base decorator class. It should have a field for storing a reference to a wrapped object. The field should be declared with the component interface type to allow linking to concrete components as well as decorators. The base decorator must delegate all work to the wrapped object.
5. Make sure all classes implement the component interface.
6. Create concrete decorators by extending them from the base decorator. A concrete decorator must execute its behavior before or after the call to the parent method (which always delegates to the wrapped object).
7. The client code must be responsible for creating decorators and composing them in the way the client needs.

### Pros and Cons

You can extend an object's behavior without making a new subclass.

You can add or remove responsibilities from an object at runtime.

You can combine several behaviors by wrapping an object into multiple decorators.

Single Responsibility Principle.You can divide a monolithic class that implements many possible variants of behavior into several smaller classes.
* It's hard to remove a specific wrapper from the wrappers stack.
* It's hard to implement a decorator in such a way that its behavior doesn't depend on the order in the decorators stack.
* The initial configuration code of layers might look pretty ugly.
* Relations with Other Patterns
* **Adapter** changes the interface of an existing object, while **Decorator** enhances an object without changing its interface. In addition, _Decorator_ supports recursive composition, which isn't possible when you use _Adapter_.
* **Adapter** provides a different interface to the wrapped object, **Proxy** provides it with the same interface, and **Decorator** provides it with an enhanced interface.
* **Chain of Responsibility** and **Decorator** have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences. The _CoR_ handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various _Decorators_ can extend the object's behavior while keeping it consistent with the base interface. In addition, decorators aren't allowed to break the flow of the request.
* **Composite** and **Decorator** have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects. A _Decorator_ is like a _Composite_ but only has one child component. There's another significant difference: _Decorator_ adds additional responsibilities to the wrapped object, while _Composite_ just "sums up" its children's results. However, the patterns can also cooperate: you can use _Decorator_ to extend the behavior of a specific object in the _Composite_ tree.
* Designs that make heavy use of **Composite** and **Decorator** can often benefit from using **Prototype**. Applying the pattern lets you clone complex structures instead of re-constructing them from scratch.
* **Decorator** lets you change the skin of an object, while **Strategy** lets you change the guts.
* **Decorator** and **Proxy** have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a _Proxy_ usually manages the life cycle of its service object on its own, whereas the composition of _Decorators_ is always controlled by the client.

**Facade** is a structural design pattern that provides a simplified interface to a library, a framework, or any other complex set of classes.

## Chapter 3 Problem

Imagine that you must make your code work with a broad set of objects that belong to a sophisticated library or framework. Ordinarily, you'd need to initialize all of those objects, keep track of dependencies, execute methods in the correct order, and so on. As a result, the business logic of your classes would become tightly coupled to the implementation details of 3rd-party classes, making it hard to comprehend and maintain.

### 3.1 Solution

A facade is a class that provides a simple interface to a complex subsystem which contains lots of moving parts. A facade might provide limited functionality in comparison to working with the subsystem directly. However, it includes only those features that clients really care about.

Having a facade is handy when you need to integrate your app with a sophisticated library that has dozens of features, but you just need a tiny bit of its functionality. For instance, an app that uploads short funny videos with cats to social media could potentially use a professional video conversion library. However, all that it really needs is a class with the single method encode(filename, format). After creating such a class and connecting it with the video conversion library, you'll have your first facade.

When you call a shop to place a phone order, an operator is your facade to all services and departments of the shop. The operator provides you with a simple voice interface to the ordering system, payment gateways, and various delivery services.

1. The **Facade** provides convenient access to a particular part of the subsystem's functionality. It knows where to direct the client's request and how to operate all the moving parts.
2. An **Additional Facade** class can be created to prevent polluting a single facade with unrelated features that might make it yet another complex structure. Additional facades can be used by both clients and other facades.
3. The **Complex Subsystem** consists of dozens of various objects. To make them all do something meaningful, you have to dive deep into the subsystem's implementation details, such as initializing objects in the correct order and supplying them with data in the proper format. Subsystem classes aren't aware of the facade's existence. They operate within the system and work with each other directly.
4. The **Client** uses the facade instead of calling the subsystem objects directly.

## # Pseudocode

In this example, the **Facade** pattern simplifies interaction with a complex video conversion framework.

Instead of making your code work with dozens of the framework classes directly, you create a facade class which encapsulates that functionality and hides it from the rest of the code. This structure also helps you to minimize the effort of upgrading to future versions of the framework or replacing it with another one. The only thing you'd need to change in your app would be the implementation of the facade's methods.

1 // These are some of the classes of a complex 3rd-party video
2 // conversion framework. We don't control that code, therefore
3 // can't simplify it.
4
5 class VideoFile
6 // 111
7class OggCompressionCodec
8 //...
9
10 class MPEG4CompressionCodec
11 //...
12
13 class CodecFactory
14 //...
15
16 class BitrateReader
17 //...
18
19 class AudioMixer
20 //...
21
22
23 // We create a facade class to hide the framework's complexity
24 // behind a simple interface. It's a trade-off between
25 // functionality and simplicity.
26 class VideoConverter is
27 method convert(filename, format):File is
28 file = new VideoFile(filename)
29 sourceCodec = new CodecFactory.extract(file)
30 if (format == "mp4")
31 destinationCodec = new MPEG4CompressionCodec()
32 else
33 destinationCodec = new OggCompressionCodec()
34 buffer = BitrateReader.read(filename, sourceCodec)
35 result = BitrateReader.convert(buffer, destinationCodec)
36 result = (new AudioMixer()).fix(result)
37 return new File(result)
38

[MISSING_PAGE_FAIL:216]

[MISSING_PAGE_EMPTY:217]

* **Abstract Factory** can serve as an alternative to **Facade** when you only want to hide the way the subsystem objects are created from the client code.
* **Flyweight** shows how to make lots of little objects, whereas **Facade** shows how to make a single object that represents an entire subsystem.
* **Facade** and **Mediator** have similar jobs: they try to organize collaboration between lots of tightly coupled classes.
* _Facade_ defines a simplified interface to a subsystem of objects, but it doesn't introduce any new functionality. The subsystem itself is unaware of the facade. Objects within the subsystem can communicate directly.

* _Mediator_ centralizes communication between components of the system. The components only know about the mediator object and don't communicate directly.
* A **Facade** class can often be transformed into a **Singleton** since a single facade object is sufficient in most cases.
* **Facade** is similar to **Proxy** in that both buffer a complex entity and initialize it on its own. Unlike _Facade_, _Proxy_ has the same interface as its service object, which makes them interchangeable.

**Flyweight** is a structural design pattern that lets you fit more objects into the available amount of RAM by sharing common parts of state between multiple objects instead of keeping all of the data in each object.

* 5. Problem

To have some fun after long working hours, you decided to create a simple video game: players would be moving around a map and shooting each other. You chose to implement a realistic particle system and make it a distinctive feature of the game. Vast quantities of bullets, missiles, and shrapnel from explosions should fly all over the map and deliver a thrilling experience to the player.

Upon its completion, you pushed the last commit, built the game and sent it to your friend for a test drive. Although the game was running flawlessly on your machine, your friend wasn't able to play for long. On his computer, the game kept crashing after a few minutes of gameplay.

After spending several hours digging through debug logs, you discovered that the game crashed because of an insufficient amount of RAM. It turned out that your friend's rig was much less powerful than your own computer, and that's why the problem emerged so quickly on his machine.

The actual problem was related to your particle system. Each particle, such as a bullet, a missile or a piece of shrapnel was represented by a separate object containing plenty of data. At some point, when the carnage on a player's screen reached its climax, newly created particles no longer fit into the remaining RAM, so the program crashed.

### Solution

On closer inspection of the Particle class, you may notice that the color and sprite fields consume a lot more memory than other fields. What's worse is that these two fields store almost identical data across all particles. For example, all bullets have the same color and sprite.

Other parts of a particle's state, such as coordinates, movement vector and speed, are unique to each particle. After all, the values of these fields change over time. This data represents the always changing context in which the particle exists, while the color and sprite remain constant for each particle.

This constant data of an object is usually called the _intrinsic state_. It lives within the object; other objects can only read it, not change it. The rest of the object's state, often altered "from the outside" by other objects, is called the _extrinsic state_.

The Flyweight pattern suggests that you stop storing the extrinsic state inside the object. Instead, you should pass this state to specific methods which rely on it. Only the intrinsic state stays within the object, letting you reuse it in different contexts.

[MISSING_PAGE_FAIL:224]

A more elegant solution is to create a separate context class that would store the extrinsic state along with reference to the flyweight object. This approach would require having just a single array in the container class.

Wait a second! Won't we need to have as many of these contextual objects as we had at the very beginning? Technically, yes. But the thing is, these objects are much smaller than before. The most memory-consuming fields have been moved to just a few flyweight objects. Now, a thousand small contextual objects can reuse a single heavy flyweight object instead of storing a thousand copies of its data.

### Flyweight and immutability

Since the same flyweight object can be used in different contexts, you have to make sure that its state can't be modified. A flyweight should initialize its state just once, via constructor parameters. It shouldn't expose any setters or public fields to other objects.

#### Flyweight factory

For more convenient access to various flyweights, you can create a factory method that manages a pool of existing flyweight objects. The method accepts the intrinsic state of the desired flyweight from a client, looks for an existing flyweight object matching this state, and returns it if it was found. If not, it creates a new flyweight and adds it to the pool.

There are several options where this method could be placed. The most obvious place is a flyweight container. Alternatively, you could create a new factory class. Or you could make the factory method static and put it inside an actual flyweight class.
1. The Flyweight pattern is merely an optimization. Before applying it, make sure your program does have the RAM consumption problem related to having a massive number of similar objects in memory at the same time. Make sure that this problem can't be solved in any other meaningful way.
2. The **Flyweight** class contains the portion of the original object's state that can be shared between multiple objects. The same flyweight object can be used in many different contexts. The state stored inside a flyweight is called "intrinsic." The state passed to the flyweight's methods is called "extrinsic."
3. The **Context** class contains the extrinsic state, unique across all original objects. When a context is paired with one of the flyweight objects, it represents the full state of the original object.
4. Usually, the behavior of the original object remains in the flyweight class. In this case, whoever calls a flyweight's method must also pass appropriate bits of the extrinsic state into the method's parameters. On the other hand, the behavior can be moved to the context class, which would use the linked flyweight merely as a data object.
5. The **Client** calculates or stores the extrinsic state of flyweights. From the client's perspective, a flyweight is a template object which can be configured at runtime by passing some contextual data into parameters of its methods.

The Flyweight Factory manages a pool of existing flyweights. With the factory, clients don't create flyweights directly. Instead, they call the factory, passing it bits of the intrinsic state of the desired flyweight. The factory looks over previously created flyweights and either returns an existing one that matches search criteria or creates a new one if nothing is found.

## # Pseudocode

In this example, the Flyweight pattern helps to reduce memory usage when rendering millions of tree objects on a canvas.

The pattern extracts the repeating intrinsic state from a main Tree class and moves it into the flyweight class TreeType.

[MISSING_PAGE_FAIL:229]

if(type==null)
26 type=newTreeType(name,color,texture)
27 treeTypes.add(type)
28returntype
29
30//The contextual object contains the extrinsic part of the tree
31//state. An application can create billions of these since they
32//are pretty small: just two integer coordinates and one
33//reference field.
34classTreeis
35fieldx,y
36fieldtype:TreeType
37constructorTree(x,y,type){....}
38methoddraw(canvas)is
39type.draw(canvas,this.x,this.y)
40
41//The Tree and the Forest classes are the flyweight's clients.
42//You can merge them if you don't plan to develop the Tree
43//class any further.
44classForestis
45fieldtrees:collection of Trees
46
47methodplantTree(x,y,name,color,texture)is
48type=TreeFactory.getTreeType(name,color,texture)
49tree=newTree(x,y,type)
50trees.add(tree)
51
52methoddraw(canvas)is
53foreach(treeintrees)do
54tree.draw(canvas)* [1] The benefit of applying the pattern depends heavily on how and where it's used. It's most useful when:
* an application needs to spawn a huge number of similar objects
* this drains all available RAM on a target device
* the objects contain duplicate states which can be extracted and shared between multiple objects

* How to Implement

1. Divide fields of a class that will become a flyweight into two parts:

* the intrinsic state: the fields that contain unchanging data duplicated across many objects
* the extrinsic state: the fields that contain contextual data unique to each object

2. Leave the fields that represent the intrinsic state in the class, but make sure they're immutable. They should take their initial values only inside the constructor.

Go over methods that use fields of the extrinsic state. For each field used in the method, introduce a new parameter and use it instead of the field.
4. Optionally, create a factory class to manage the pool of flyweights. It should check for an existing flyweight before creating a new one. Once the factory is in place, clients must only request flyweights through it. They should describe the desired flyweight by passing its intrinsic state to the factory.
5. The client must store or calculate values of the extrinsic state (context) to be able to call methods of flyweight objects. For the sake of convenience, the extrinsic state along with the flyweight-referencing field may be moved to a separate context class.

### Pros and Cons

You can save lots of RAM, assuming your program has tons of similar objects.

You might be trading RAM over CPU cycles when some of the context data needs to be recalculated each time somebody calls a flyweight method.

The code becomes much more complicated. New team members will always be wondering why the state of an entity was separated in such a way.

Relations with Other Patterns

You can implement shared leaf nodes of the **Composite** tree as **Flyweights** to save some RAM.

**Flyweight** shows how to make lots of little objects, whereas **Facade** shows how to make a single object that represents an entire subsystem.

**Flyweight** would resemble **Singleton** if you somehow managed to reduce all shared states of the objects to just one flyweight object. But there are two fundamental differences between these patterns:

1. There should be only one Singleton instance, whereas a _Flyweight_ class can have multiple instances with different intrinsic states.
2. The _Singleton_ object can be mutable. Flyweight objects are immutable.

**Proxy** is a structural design pattern that lets you provide a substitute or placeholder for another object. A proxy controls access to the original object, allowing you to perform something either before or after the request gets through to the original object.

3. Problem

Why would you want to control access to an object? Here is an example: you have a massive object that consumes a vast amount of system resources. You need it from time to time, but not always.

You could implement lazy initialization: create this object only when it's actually needed. All of the object's clients would need to execute some deferred initialization code. Unfortunately, this would probably cause a lot of code duplication.

In an ideal world, we'd want to put this code directly into our object's class, but that isn't always possible. For instance, the class may be part of a closed 3rd-party library.

2. Solution

The Proxy pattern suggests that you create a new proxy class with the same interface as an original service object. Then you update your app so that it passes the proxy object to all of the original object's clients. Upon receiving a request from a client, the proxy creates a real service object and delegates all the work to it.

But what's the benefit? If you need to execute something either before or after the primary logic of the class, the proxy lets you do this without changing that class. Since the proxy implements the same interface as the original class, it can be passed to any client that expects a real service object.

A credit card is a proxy for a bank account, which is a proxy for a bundle of cash. Both implement the same interface: they can be used for making a payment. A consumer feels great because there's no need to carry loads of cash around. A shop owner is also happy since the income from a transaction gets added electronically to the shop's bank account without the risk of losing the deposit or getting robbed on the way to the bank.

## 9 Structure

1. The **Service Interface** declares the interface of the Service. The proxy must follow this interface to be able to disguise itself as a service object.
2. The **Service** is a class that provides some useful business logic.

3. The **Proxy** class has a reference field that points to a service object. After the proxy finishes its processing (e.g., lazy initialization, logging, access control, caching, etc.), it passes the request to the service object. Usually, proxies manage the full lifecycle of their service objects.
4. The **Client** should work with both services and proxies via the same interface. This way you can pass a proxy into any code that expects a service object.

## # Pseudocode

This example illustrates how the **Proxy** pattern can help to introduce lazy initialization and caching to a 3rd-party YouTube integration library.

_Caching results of a service with a proxy._The library provides us with the video downloading class. However, it's very inefficient. If the client application requests the same video multiple times, the library just downloads it over and over, instead of caching and reusing the first downloaded file.

The proxy class implements the same interface as the original downloader and delegates it all the work. However, it keeps track of the downloaded files and returns the cached result when the app requests the same video multiple times.

```
1//Theinterfaceofaremotestor.
2interfaceThirdPartyYoutubeLibis
3methodlistVideos()
4methodgetVideoInfo(id)
5methoddownloadVideo(id)
6
7//Theconcreteimplementationofaserviceconnector.Methods
8//ofthisclasscanrequestinformationfromYouTube.Thespeed
9//oftherequestdependsonauser'sinternetconnectionas
10//wellasYouTube's.Theapplicationwillslowdownifalotof
11//requestsarefiredatthesametime,eveniftheyallrequest
12//thesameinformation.
13classThirdPartyYoutubeClassimplementsThirdPartyYoutubeLibis
14methodlistVideos()is
15//SendanAPIrequesttoYouTube.
16
17methodgetVideoInfo(id)is
18//Getmetadataaboutsomevideo.
19method downloadVideo(id)is
21 // Download a video file from YouTube.
22
23 // To save some bandwidth, we can cache request results and keep
24 // them for some time. But it may be impossible to put such code
25 // directly into the service class. For example, it could have
26 // been provided as part of a third party library and/or defined
27 // as 'final'. That's why we put the caching code into a new
28 // proxy class which implements the same interface as the
29 // service class. It delegates to the service object only when
30 // the real requests have to be sent.
31 **class CachedYoutubeClass implements ThirdPartyYouTubeLib is**
32 **private field** service: ThirdPartyYouTubeLib **is**
33 **private field** listCache, videoCache
34 **field** needReset
35
36 **constructor** CachedYoutubeClass(service: ThirdPartyYouTubeLib)is**
37 **this.service** = service
38
39 **method** listVideos()is
40 **if** (listCache == **null** || needReset)
41 **listCache** = service.listVideos()
42 **return** listCache
43
44 **method** getVideoInfo(id)is**
45 **if** (videoCache == **null** || needReset)
46 **videoCache** = service.getVideoInfo(id)
47 **return** videoCache
48
49 **method** downloadVideo(id)is**
50 **if** (!downloadExists(id) || needReset)
51 **service.downloadVideo(id)// The GUI class, which used to work directly with a service
* // object, stays unchanged as long as it works with the service
* // object through an interface. We can safely pass a proxy
* // object instead of a real service object since they both
* // implement the same interface.
* 57class YoutubeManager is
* 58 protected field service: ThirdPartyYouTubeLib
* 59
* 60 constructor YoutubeManager(service: ThirdPartyYouTubeLib) is
* 61 this.service = service
* 62
* 63 method renderVideoPage(id) is
* 64 info = service.getVideoInfo(id)
* 65 // Render the video page.
* 66
* 67 method renderListPanel() is
* 68 list = service.listVideos()
* 69 // Render the list of video thumbnails.
* 70
* 71 method reactOnUserInput() is
* 72 renderVideoPage()
* 73 renderListPanel()
* 74
* 75 // The application can configure proxies on the fly.
* 76 class Application is
* 77 method init() is
* 78 aYouTubeService = new ThirdPartyYouTubeClass()
* 79 aYouTubeProxy = new CachedYouTubeClass(aYouTubeService)
* 80 manager = new YouTubeManager(aYouTubeProxy)
* 81 manager.reactOnUserInput()

[MISSING_PAGE_EMPTY:242]

[MISSING_PAGE_EMPTY:243]

[MISSING_PAGE_EMPTY:244]

* **Pros and Cons**
* **You can control the service object without clients knowing about it.**
* **You can manage the lifecycle of the service object when clients don't care about it.**
* **The proxy works even if the service object isn't ready or is not available.**
* **_Open/Closed Principle._ **You can introduce new proxies without changing the service or clients.**
* **The code may become more complicated since you need to introduce a lot of new classes.**
* **The response from the service might get delayed.**
* **Relations with Other Patterns**
* **Adapter provides a different interface to the wrapped object,**
* **Proxy provides it with the same interface, and**
* **Decorator provides it with an enhanced interface.**
* **Facade is similar to**
* **Proxy in that both buffer a complex entity and initialize it on its own. Unlike**
* **_Facade, Proxy has the same interface as its service object, which makes them interchangeable.**
* **Decorator and**
* **Proxy have similar structures, but very different intents. Both patterns are built on the composition principle,where one object is supposed to delegate some of the work to another. The difference is that a _Proxy_ usually manages the life cycle of its service object on its own, whereas the composition of _Decorators_ is always controlled by the client.

Behavioral Design Patterns

Behavioral patterns are concerned with algorithms and the assignment of responsibilities between objects.

Lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.

Turns a request into a stand-alone object that contains all information about the request. This transformation lets you parameterize methods with different requests, delay or queue a request's execution, and support undoable operations.

[MISSING_PAGE_EMPTY:248]

[MISSING_PAGE_EMPTY:249]

[MISSING_PAGE_EMPTY:250]

**Chain of Responsibility**

**Chain of Responsibility**

**you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.**

[MISSING_PAGE_EMPTY:252]

* One of your colleagues suggested that it's unsafe to pass raw data straight to the ordering system. So you added an extra validation step to sanitize the data in a request.
* Later, somebody noticed that the system is vulnerable to brute force password cracking. To negate this, you promptly added a check that filters repeated failed requests coming from the same IP address.
* Someone else suggested that you could speed up the system by returning cached results on repeated requests containing the same data. Hence, you added another check which lets the request pass through to the system only if there's no suitable cached response.

_The bigger the code grew, the messier it became._The code of the checks, which had already looked like a mess, became more and more bloated as you added each new feature. Changing one check sometimes affected the others. Worst of all, when you tried to reuse the checks to protect other components of the system, you had to duplicate some of the code since those components required some of the checks, but not all of them.

The system became very hard to comprehend and expensive to maintain. You struggled with the code for a while, until one day you decided to refactor the whole thing.

### Solution

Like many other behavioral design patterns, the **Chain of Responsibility** relies on transforming particular behaviors into stand-alone objects called _handlers_. In our case, each check should be extracted to its own class with a single method that performs the check. The request, along with its data, is passed to this method as an argument.

The pattern suggests that you link these handlers into a chain. Each linked handler has a field for storing a reference to the next handler in the chain. In addition to processing a request, handlers pass the request further along the chain. The request travels along the chain until all handlers have had a chance to process it.

Here's the best part: a handler can decide not to pass the request further down the chain and effectively stop any further processing.

In our example with ordering systems, a handler performs the processing and then decides whether to pass the request further down the chain. Assuming the request contains the right data, all the handlers can execute their primary behavior, whether it's authentication checks or caching.

However, there's a slightly different approach (and it's a bit more canonical) in which, upon receiving a request, a handler decides whether it can process it. If it can, it doesn't pass the request any further. So it's either only one handler that processes the request or none at all. This approach is very common when dealing with events in stacks of elements within a graphical user interface.

For instance, when a user clicks a button, the event propagates through the chain of GUI elements that starts with the button, goes along its containers (like forms or panels), and ends up with the main application window. The event is processed by the first element in the chain that's capable of handling it. Thisexample is also noteworthy because it shows that a chain can always be extracted from an object tree.

It's crucial that all handler classes implement the same interface. Each concrete handler should only care about the following one having the execute method. This way you can compose chains at runtime, using various handlers without coupling your code to their concrete classes.

### Real-World Analogy

You've just bought and installed a new piece of hardware on your computer. Since you're a geek, the computer has several operating systems installed. You try to boot all of them to see whether the hardware is supported. Windows detects and enables the hardware automatically. However, your beloved Linux refuses to work with the new hardware. With a small flicker of hope, you decide to call the tech-support phone number written on the box.

The first thing you hear is the robotic voice of the autoresponder. It suggests nine popular solutions to various problems, none of which are relevant to your case. After a while, the robot connects you to a live operator.

Alas, the operator isn't able to suggest anything specific either. He keeps quoting lengthy excerpts from the manual, refusing to listen to your comments. After hearing the phrase "have you tried turning the computer off and on again?" for the 10th time, you demand to be connected to a proper engineer.

Eventually, the operator passes your call to one of the engineers, who had probably longed for a live human chat for hours as he sat in his lonely server room in the dark basement of some office building. The engineer tells you where to down load proper drivers for your new hardware and how to install them on Linux. Finally, the solution! You end the call, bursting with joy.

## 9 Structure

1. The **Handler** declares the interface, common for all concrete handlers. It usually contains just a single method for handling requests, but sometimes it may also have another method for setting the next handler on the chain.

The Base Handler is an optional class where you can put the boilerplate code that's common to all handler classes.

Usually, this class defines a field for storing a reference to the next handler. The clients can build a chain by passing a handler to the constructor or setter of the previous handler. The class may also implement the default handling behavior: it can pass execution to the next handler after checking for its existence.
3. **Concrete Handlers** contain the actual code for processing requests. Upon receiving a request, each handler must decide whether to process it and, additionally, whether to pass it along the chain.

Handlers are usually self-contained and immutable, accepting all necessary data just once via the constructor.
4. The **Client** may compose chains just once or compose them dynamically, depending on the application's logic. Note that a request can be sent to any handler in the chain\(-\)it doesn't have to be the first one.

## # Pseudocode

In this example, the **Chain of Responsibility** pattern is responsible for displaying contextual help information for active GUI elements.

The application's GUI is usually structured as an object tree. For example, the Dialog class, which renders the main window of the app, would be the root of the object tree. The dialog contains Panels, which might contain other panels or simple low-level elements like Buttons and TextFields. A simple component can show brief contextual tooltips, as long as the component has some help text assigned. But more complex components define their own way of showing contextual help, such as showing an excerpt from the manual or opening a page in a browser.

When a user points the mouse cursor at an element and presses the F1 key, the application detects the component under the pointer and sends it a help request. The request bubbles up through all the elements containers until it reaches the element that's capable of displaying the help information.

1// The handler interface declares a method for building a chain
2//of handlers. It also declares a method for executing a
3//request.
4interface ComponentWithContextuaIHeUp is
5method showHelp()
6
7
8//The base class for simple components.
9abstract class Component implements ComponentWithContextuaIHelp is
10field tooltipText: string
11
12//The component's container acts as the next link in the
13//chain of handlers.
14protected field container: Container
15
16//The component shows a tooltip if there's help text
17//assigned to it. Otherwise it forwards the call to the
18//container, if it exists.
19method showHelp() is
20if(tooltipText!= null)
21//Show tooltip.
22else
23container.showHelp()
24
25
26//Containers can contain both simple components and other
27//containers as children. The chain relationships are
28//established here. The class inherits showHelp behavior from
29//its parent.
30abstract class Container extends Component is
31protected field children: array of Component
32method add(child) is
34 children.add(child)
35 child.container = this
36
37
38 // Primitive components may be fine with default help
39 // implementation...
40 class Button extends Component is
41 //...
42
43 // But complex components may override the default
44 // implementation. If the help text can't be provided in a new
45 // way, the component can always call the base implementation
46 // (see Component class).
47 class Panel extends Container is
48 field modalHelpText: string
49
50 method showHelp() is
51 if (modalHelpText!= null)
52 // Show a modal window with the help text.
53 else
54 super.showHelp()
55
56 //...same as above...
57 class Dialog extends Container is
58 field wikiPageURL: string
59
50 method showHelp() is
61 if (wikiPageURL!= null)
62 // Open the wiki help page.
63 else
64 super.showHelp()//Clientcode.
66classApplicationis
67//Everyapplicationconfiguresthechaindifferently.
68methodcreateUI()is
69dialog=newDialog("BudgetReports")
70dialog.wikiPageURL="http://..."
71panel=newPanel(0,0,400,800)
72panel.modalHelpText="Thispaneldoes..."
73ok=newButton(250,760,50,20,"OK")
74ok.tooUtipText="ThisisanOKbuttonthat..."
75cancel=newButton(320,760,50,20,"Cancel")
76//...
77panel.add(ok)
78panel.add(cancel)
79dialog.add(panel)
80
81//Imaginewhathappenshere.
82methodonF1KeyPress()is
83component=this.getComponentAtMouseCoords()
84component.showHelp()
85Applicability
86Use the Chain of Responsibility pattern when your program is expected to process different kinds of requests in various ways, but the exact types of requests and their sequences are unknown beforehand.
87The pattern lets you link several handlers into one chain and, upon receiving a request, "ask" each handler whether it can process it. This way all handlers get a chance to process the request.

### Use the pattern when it's essential to execute several handlers in a particular order.

Since you can link the handlers in the chain in any order, all requests will get through the chain exactly as you planned.

### Use the CoR pattern when the set of handlers and their order are supposed to change at runtime.

If you provide setters for a reference field inside the handler classes, you'll be able to insert, remove or reorder handlers dynamically.

### How to Implement

1. Declare the handler interface and describe the signature of a method for handling requests. Decide how the client will pass the request data into the method. The most flexible way is to convert the request into an object and pass it to the handling method as an argument.
2. To eliminate duplicate boilerplate code in concrete handlers, it might be worth creating an abstract base handler class, derived from the handler interface.

This class should have a field for storing a reference to the next handler in the chain. Consider making the class immutable. However, if you plan to modify chains at runtime, you need to define a setter for altering the value of the reference field. You can also implement the convenient default behavior for the handling method, which is to forward the request to the next object unless there's none left. Concrete handlers will be able to use this behavior by calling the parent method.
3. One by one create concrete handler subclasses and implement their handling methods. Each handler should make two decisions when receiving a request: * Whether it'll process the request. * Whether it'll pass the request along the chain.
4. The client may either assemble chains on its own or receive pre-built chains from other objects. In the latter case, you must implement some factory classes to build chains according to the configuration or environment settings.
5. The client may trigger any handler in the chain, not just the first one. The request will be passed along the chain until some handler refuses to pass it further or until it reaches the end of the chain.

* 6. Due to the dynamic nature of the chain, the client should be ready to handle the following scenarios:
* The chain may consist of a single link.
* Some requests may not reach the end of the chain.
* Others may reach the end of the chain unhandled.

### Pros and Cons

You can control the order of request handling. _Single Responsibility Principle._ You can decouple classes that invoke operations from classes that perform operations. _Open/Closed Principle._ You can introduce new handlers into the app without breaking the existing client code.

Some requests may end up unhandled.

### Relations with Other Patterns

* **Chain of Responsibility, Command, Mediator*
* and **Observer*
* address various ways of connecting senders and receivers of requests:
* _Chain of Responsibility_ passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.
* _Command_ establishes unidirectional connections between senders and receivers.
* _Mediator_ eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.
* _Observer_ lets receivers dynamically subscribe to and unsubscribe from receiving requests.
* **Chain of Responsibility** is often used in conjunction with **Composite**. In this case, when a leaf component gets a request, it may pass it through the chain of all of the parent components down to the root of the object tree.
* Handlers in **Chain of Responsibility** can be implemented as **Commands**. In this case, you can execute a lot of different operations over the same context object, represented by a request. However, there's another approach, where the request itself is a _Command_ object. In this case, you can execute the same operation in a series of different contexts linked into a chain.
* **Chain of Responsibility** and **Decorator** have very similar class structures. Both patterns rely on recursive composition to pass the execution through a series of objects. However, there are several crucial differences. The _CoR_ handlers can execute arbitrary operations independently of each other. They can also stop passing the request further at any point. On the other hand, various _Decorators_ can extend the object's behavior while keeping it consistent with the base interface. In addition, decorators aren't allowed to break the flow of the request.

**Command** is a behavioral design pattern that turns a request into a stand-alone object that contains all information about the request. This transformation lets you parameterize methods with different requests, delay or queue a request's execution, and support undoable operations.

[MISSING_PAGE_EMPTY:270]

Before long, you realize that this approach is deeply flawed. First, you have an enormous number of subclasses, and that would be okay if you weren't risking breaking the code in these subclasses each time you modify the base Button class. Put simply, your GUI code has become awkwardly dependent on the volatile code of the business logic.

And here's the ugliest part. Some operations, such as copying/pasting text, would need to be invoked from multiple places. For example, a user could click a small "Copy" button on the toolbar, or copy something via the context menu, or just hit Ctrl+C on the keyboard.

Initially, when our app only had the toolbar, it was okay to place the implementation of various operations into the button subclasses. In other words, having the code for copying text inside the CopyButton subclass was fine. But then, when you implement context menus, shortcuts, and other stuff, you have to either duplicate the operation's code in many classes or make menus dependent on buttons, which is an even worse option.

### Solution

Good software design is often based on the principle of separation of concerns, which usually results in breaking an app into layers. The most common example: a layer for the graphical user interface and another layer for the business logic. The GUI layer is responsible for rendering a beautiful picture on the screen, capturing any input and showing results of what the user and the app are doing. However, when it comes to doing something important, like calculating the trajectory of the moon or composing an annual report, the GUI layer delegates the work to the underlying layer of business logic.

In the code it might look like this: a GUI object calls a method of a business logic object, passing it some arguments. This process is usually described as one object sending another a request.

The Command pattern suggests that GUI objects shouldn't send these requests directly. Instead, you should extract all of the request details, such as the object being called, the name of the method and the list of arguments into a separate _command_ class with a single method that triggers this request.

Command objects serve as links between various GUI and business logic objects. From now on, the GUI object doesn't need to know what business logic object will receive the request and how it'll be processed. The GUI object just triggers the command, which handles all the details.

_Accessing the business logic layer via a command._The next step is to make your commands implement the same interface. Usually it has just a single execution method that takes no parameters. This interface lets you use various commands with the same request sender, without coupling it to concrete classes of commands. As a bonus, now you can switch command objects linked to the sender, effectively changing the sender's behavior at runtime.

You might have noticed one missing piece of the puzzle, which is the request parameters. A GUI object might have supplied the business-layer object with some parameters. Since the command execution method doesn't have any parameters, how would we pass the request details to the receiver? It turns out the command should be either pre-configured with this data, or capable of getting it on its own.

The GUI objects delegate the work to commands.

Let's get back to our text editor. After we apply the Command pattern, we no longer need all those button subclasses to implement various click behaviors. It's enough to put a single field into the base Button class that stores a reference to a command object and make the button execute that command on a click.

You'll implement a bunch of command classes for every possible operation and link them with particular buttons, depending on the buttons' intended behavior.

Other GUI elements, such as menus, shortcuts or entire dialogs, can be implemented in the same way. They'll be linked to a command which gets executed when a user interacts with the GUI element. As you've probably guessed by now, the elements related to the same operations will be linked to the same commands, preventing any code duplication.

As a result, commands become a convenient middle layer that reduces coupling between the GUI and business logic layers. And that's only a fraction of the benefits that the Command pattern can offer!After a long walk through the city, you get to a nice restaurant and sit at the table by the window. A friendly waiter approaches you and quickly takes your order, writing it down on a piece of paper. The waiter goes to the kitchen and sticks the order on the wall. After a while, the order gets to the chef, who reads it and cooks the meal accordingly. The cook places the meal on a tray along with the order. The waiter discovers the tray, checks the order to make sure everything is as you wanted it, and brings everything to your table.

The paper order serves as a command. It remains in a queue until the chef is ready to serve it. The order contains all the relevant information required to cook the meal. It allows the chef to start cooking right away instead of running around clarifying the order details from you directly.

1. The **Sender** class (aka _invoker_) is responsible for initiating requests. This class must have a field for storing a reference to a command object. The sender triggers that command instead of sending the request directly to the receiver. Note that the sender isn't responsible for creating the command object. Usually, it gets a pre-created command from the client via the constructor.
2. The **Command** interface usually declares just a single method for executing the command.
3. **Concrete Commands** implement various kinds of requests. A concrete command isn't supposed to perform the work on its own, but rather to pass the call to one of the business logic objects. However, for the sake of simplifying the code, these classes can be merged.

Parameters required to execute a method on a receiving object can be declared as fields in the concrete command. You can make command objects immutable by only allowing the initialization of these fields via the constructor.

4. The **Receiver** class contains some business logic. Almost any object may act as a receiver. Most commands only handle the details of how a request is passed to the receiver, while the receiver itself does the actual work.

5. The **Client** creates and configures concrete command objects. The client must pass all of the request parameters, including a receiver instance, into the command's constructor. After that, the resulting command may be associated with one or multiple senders.

## 4 Pseudocode

In this example, the **Command** pattern helps to track the history of executed operations and makes it possible to revert an operation if needed.

Commands which result in changing the state of the editor (e.g., cutting and pasting) make a backup copy of the editor's state before executing an operation associated with the command. After a command is executed, it's placed into the command history (a stack of command objects) along with the backup copy of the editor's state at that point. Later, if the user needs to revert an operation, the app can take the most recent command from the history, read the associated backup of the editor's state, and restore it.

[MISSING_PAGE_EMPTY:280]

// The concrete commands go here.
27class CopyCommand extends Command is
28// The copy command isn't saved to the history since it
29// doesn't change the editor's state.
30method execute() is
31app.clipboard = editor.getSelection()
32return false
33
34class CutCommand extends Command is
35// The cut command does change the editor's state, therefore
36// it must be saved to the history. And it'll be saved as
37// long as the method returns true.
38method execute() is
39saveBackup()
40app.clipboard = editor.getSelection()
41editor.deleteSelection()
42return true
43
44class PasteCommand extends Command is
45method execute() is
46saveBackup()
47editor.replaceSelection(app.clipboard)
48return true
49
50// The undo operation is also a command.
51class UndoCommand extends Command is
52method execute() is
53app.undo()
54return false
55
56
57// The global command history is just a stack.

classCommandHistory is
59 private field history: array of Command
60
61 // Last in...
62 method push(c: Command) is
63 // Push the command to the end of the history array.
64
65 //...first out
66 method pop():Command is
67 // Get the most recent command from the history.
68
69
70 // The editor class has actual text editing operations. It plays
71 // the role of a receiver: all commands end up delegating
72 // execution to the editor's methods.
73 class Editor is
74 field text: string
75
76 method getSelection() is
77 // Return selected text.
78
79 method deleteSelection() is
80 // Deletes selected text.
81
82 method replaceSelection(text) is
83 // Insert the clipboard's contents at the current
84 // position.
85
86
87 // The application class sets up object relations. It acts as a
88 // sender: when something needs to be done, it creates a command
89 // object and executes it.

classApplicationis
91fieldclipboard:string
92fieldeditors:arrayofEditors
93fieldactiveEditor:Editor
94fieldhistory:CommandHistory
95
96//ThecodewhichassignscommandstotUIobjectsmaylook
97//likethis.
98methodcreateUI()is
99//...
100copy=function(){executeCommand(
101newCopyCommand(this,activeEditor))}
102copyButton.setCommand(copy)
103shortcuts.onKeyPress("Ctrl+C",copy)
104
105cut=function(){executeCommand(
106newCutCommand(this,activeEditor))}
107cutButton.setCommand(cut)
108shortcuts.onKeyPress("Ctrl+X",cut)
109
110past=function(){executeCommand(
111newPasteCommand(this,activeEditor))}
112pasteButton.setCommand(paste)
113shortcuts.onKeyPress("Ctrl+V",paste)
114
115undo=function(){executeCommand(
116newUndoCommand(this,activeEditor))}
117undoButton.setCommand(undo)
118shortcuts.onKeyPress("Ctrl+Z",undo)
119
120//Executeacommandandcheckwhetherithastobeaddedto121//thehistory.

122 method executeCommand(command) is
123 if(command.execute)
124 history.push(command)
125
126 // Take the most recent command from the history and run its
127 // undo method. Note that we don't know the class of that
128 // command. But we don't have to, since the command knows
129 // how to undo its own action.
130 method undo() is
131 command = history.pop()
132 if(command!= null)
133 command.undo()

### **Calculation of the Command pattern**

The Command pattern can turn a specific method call into a stand-alone object. This change opens up a lot of interesting uses: you can pass commands as method arguments, store them inside other objects, switch linked commands at runtime, etc.

Here's an example: you're developing a GUI component such as a context menu, and you want your users to be able to configure menu items that trigger operations when an end user clicks an item.

* [16] **Use the Command pattern when you want to queue operations, schedule their execution, or execute them remotely.**
* [17] **As with any other object, a command can be serialized, which means converting it to a string that can be easily written to a file or a database. Later, the string can be restored as the initial command object. Thus, you can delay and schedule command execution. But there's even more! In the same way, you can queue, log or send commands over the network.**
* [18] **Use the Command pattern when you want to implement reversible operations.**
* [19] **Although there are many ways to implement undo/redo, the Command pattern is perhaps the most popular of all.**
* [20] **To be able to revert operations, you need to implement the history of performed operations. The command history is a stack that contains all executed command objects along with related backups of the application's state.**
* [21] **This method has two drawbacks. First, it isn't that easy to save an application's state because some of it can be private. This problem can be mitigated with the** **Memento pattern.**
* [22] **Second, the state backups may consume quite a lot of RAM. Therefore, sometimes you can resort to an alternative implementation: instead of restoring the past state, the command performs the inverse operation. The reverse operation also has a price: it may turn out to be hard or even impossible to implement.

## How to Implement

1. Declare the command interface with a single execution method.
2. Start extracting requests into concrete command classes that implement the command interface. Each class must have a set of fields for storing the request arguments along with a reference to the actual receiver object. All these values must be initialized via the command's constructor.
3. Identify classes that will act as _senders_. Add the fields for storing commands into these classes. Senders should communicate with their commands only via the command interface. Senders usually don't create command objects on their own, but rather get them from the client code.
4. Change the senders so they execute the command instead of sending a request to the receiver directly.
5. The client should initialize objects in the following order: * Create receivers. * Create commands, and associate them with receivers if needed.

* [16] _The code may become more complicated since you're introducing a whole new layer between senders and receivers._
* [17] _Relations with Other Patterns_
* [18] _Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:_
* [19] _Chain of Responsibility passes a request sequentially along a dynamic chain of potential receivers until one of them handles it._
* [20] _Command_ establishes unidirectional connections between senders and receivers.

* _Mediator_ eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.
* _Observer_ lets receivers dynamically subscribe to and unsubscribe from receiving requests.
* Handlers in **Chain of Responsibility** can be implemented as **Commands**. In this case, you can execute a lot of different operations over the same context object, represented by a request. However, there's another approach, where the request itself is a _Command_ object. In this case, you can execute the same operation in a series of different contexts linked into a chain.
* You can use **Command** and **Memento** together when implementing "undo". In this case, commands are responsible for performing various operations over a target object, while mementos save the state of that object just before a command gets executed.
* **Command** and **Strategy** may look similar because you can use both to parameterize an object with some action. However, they have very different intents.
* You can use _Command_ to convert any operation into an object. The operation's parameters become fields of that object. The conversion lets you defer execution of the operation, queue it, store the history of commands, send commands to remote services, etc.
* On the other hand, _Strategy_ usually describes different ways of doing the same thing, letting you swap these algorithms within a single context class.
* **Prototype** can help when you need to save copies of **Commands** into history.
* You can treat **Visitor** as a powerful version of the **Command** pattern. Its objects can execute operations over various objects of different classes.

**Iterator** is a behavioral design pattern that lets you traverse elements of a collection without exposing its underlying representation (list, stack, tree, etc.).

* 3. Problem Collections are one of the most used data types in programming. Nonetheless, a collection is just a container for a group of objects.

Most collections store their elements in simple lists. However, some of them are based on stacks, trees, graphs and other complex data structures.

But no matter how a collection is structured, it must provide some way of accessing its elements so that other code can use these elements. There should be a way to go through each element of the collection without accessing the same elements over and over.

This may sound like an easy job if you have a collection based on a list. You just loop over all of the elements. But how do you sequentially traverse elements of a complex data structure, such as a tree? For example, one day you might be just fine with depth-first traversal of a tree. Yet the next day you might require breadth-first traversal. And the next week, you might need something else, like random access to the tree elements.

Adding more and more traversal algorithms to the collection gradually blurs its primary responsibility, which is efficient data storage. Additionally, some algorithms might be tailored for a specific application, so including them into a generic collection class would be weird.

On the other hand, the client code that's supposed to work with various collections may not even care how they store their elements. However, since collections all provide different ways of accessing their elements, you have no option other than to couple your code to the specific collection classes.

## Solution

The main idea of the Iterator pattern is to extract the traversal behavior of a collection into a separate object called an _iterator_.

In addition to implementing the algorithm itself, an iterator object encapsulates all of the traversal details, such as the current position and how many elements are left till the end.

Because of this, several iterators can go through the same collection at the same time, independently of each other.

Usually, iterators provide one primary method for fetching elements of the collection. The client can keep running this method until it doesn't return anything, which means that the iterator has traversed all of the elements.

All iterators must implement the same interface. This makes the client code compatible with any collection type or any traversal algorithm as long as there's a proper iterator. If you need a special way to traverse a collection, you just create a new iterator class, without having to change the collection or the client.

You plan to visit Rome for a few days and visit all of its main sights and attractions. But once there, you could waste a lot of time walking in circles, unable to find even the Colosseum.

On the other hand, you could buy a virtual guide app for your smartphone and use it for navigation. It's smart and inexpensive, and you could be staying at some interesting places for as long as you want. Another alternative is that you could spend some of the trip's budget and hire a local guide who knows the city like the back of his hand. The guide would be able to tailor the tour to your likings, show you every attraction and tell a lot of exciting stories. That'll be even more fun; but, alas, more expensive, too.

All of these options\(-\)the random directions born in your head, the smartphone navigator or the human guide\(-\)act as iterators over the vast collection of sights and attractions located in Rome.

### Structure

1. The **Iterator** interface declares the operations required for traversing a collection: fetching the next element, retrieving the current position, restarting iteration, etc.

2. **Concrete Iterators** implement specific algorithms for traversing a collection. The iterator object should track the traversal progress on its own. This allows several iterators to traverse the same collection independently of each other.
3. The **Collection** interface declares one or multiple methods for getting iterators compatible with the collection. Note that the return type of the methods must be declared as the iterator interface so that the concrete collections can return various kinds of iterators.
4. **Concrete Collections** return new instances of a particular concrete iterator class each time the client requests one. You might be wondering, where's the rest of the collection's code? Don't worry, it should be in the same class. It's just that these details aren't crucial to the actual pattern, so we're omitting them.
5. The **Client** works with both collections and iterators via their interfaces. This way the client isn't coupled to concrete classes, allowing you to use various collections and iterators with the same client code. Typically, clients don't create iterators on their own, but instead get them from collections. Yet, in certain cases, the client can create one directly; for example, when the client defines its own special iterator.

## # Pseudocode

In this example, the **Iterator** pattern is used to walk through a special kind of collection which encapsulates access to Facebook's social graph. The collection provides several iterators that can traverse profiles in various ways.

The 'friends' iterator can be used to go over the friends of a given profile. The 'colleague' iterator does the same, except itomits friends who don't work at the same company as a target person. Both iterators implement a common interface which allows clients to fetch profiles without diving into implementation details such as authentication and sending REST requests.

The client code isn't coupled to concrete classes because it works with collections and iterators only through interfaces. If you decide to connect your app to a new social network, you simply need to provide new collection and iterator classes without changing the existing code.

```
1//Thecollectioninterfacemustdeclareafactorymethodfor
2//producingiterators.Youcandeclareseveralmethodsifthere
3//aredifferentkindsofiterationavailableinyourprogram.
4interfaceSocialNetworkis
5methodcreateFriendsIterator(profileId):ProfileIterator
6methodcreateCoworkersIterator(profileId):ProfileIterator
7
8//Eachconcretecollectioniscoupledtoastofconcrete
9//iteratorclassesitreturns.Buttheclientis't,sincethe
10//signatureofthesemethodsreturnsiteratorinterfaces.
11classFacebookimplementsSocialNetworkis
12//...Thebulkofthecollection'scodeshouldgohere...
13
14//Iteratorcreationcode.
15methodcreateFriendsIterator(profileId)is
16returnnewFacebookIterator(this,profileId, "friends")
17methodcreateCoworkersIterator(profileId)is
18returnnewFacebookIterator(this,profileId, "coworkers")// The common interface for all iterators.
20interface ProfileIterator is
21method getNext():Profile
22method hasMore():bool
23
24
25// The concrete iterator class.
26class FacebookIterator implements ProfileIterator is
27// The iterator needs a reference to the collection that it
28// traverses.
29private field facebook: Facebook
30private field profileId, type: string
31
32// An iterator object traverses the collection independently
33// from other iterators. Therefore it has to store the
34// iteration state.
35private field currentPosition
36private field cache: array of Profile
37
38constructor FacebookIterator(facebook, profileId, type) is
39this.facebook = facebook
40this.profileId = profileId
41this.type = type
42
43private method lazyInit() is
44if(cache == null)
45cache = facebook.socialGraphRequest(profileId, type)
46
47// Each concrete iterator class has its own implementation
48// of the common iterator interface.
49method getNext() is
50if(hasMore())currentPosition++
* 52returncache[currentPosition]
* 53
* 54methodhasMore()is
* 55 lazyInit()
* 56returncache.length <currentPosition
* 57
* 58
* 59//Hereisanotherusefultrick:youcanpassaniteratortoa
* 60//clientclassinsteadofgivingitaccesstoawhole
* 61//collection.Thisway,youdon'texposethecollectiontothe
* 62//client.
* 63//
* 64//Andthere'sanotherbenefit:youcanchangethewaythe
* 65//clientworkswiththecollectionatruntimetbypassingita
* 66//differentiterator.Thisispossiblebecausetheclientcode
* 67//isn'tcoupledtocheretiteratorclasses.
* 68classSocialSpammeris
* 69methodsend(iterator:ProfileIterator,message:string)is
* 70while(iterator.hasNext())
* 71profile=iterator.getNext()
* 72System.sendEmail(profile.getEmail(),message)
* 73
* 74//Theapplicationclassconfigurescollectionsanditerators
* 75//andthenpassesthemtotheclientcode.
* 76classApplicationis
* 77fieldnetwork:SocialNetwork
* 78fieldspammer:SocialSpammer
* 79
* 80methodconfig()is
* 81ifworkingwithFacebook
* 82this.network=newFacebook()if working with LinkedIn
* **this.network = new LinkedIn()**
* **this.spammer = new**SociaISpammer()
* **method**sendSpamToFriends(profile) **is**
* **iterator = network.createFriendsIterator(profile.getId())**
* **spammer.send(iterator, "Very important message")**
* **method**sendSpamToCoworkers(profile) **is**
* **iterator = network.createCoworkersIterator(profile.getId())**
* **spammer.send(iterator, "Very important message")**

### Applicability

Use the Iterator pattern when your collection has a complex data structure under the hood, but you want to hide its complexity from clients (either for convenience or security reasons).

The iterator encapsulates the details of working with a complex data structure, providing the client with several simple methods of accessing the collection elements. While this approach is very convenient for the client, it also protects the collection from careless or malicious actions which the client would be able to perform if working with the collection directly.

Use the pattern to reduce duplication of the traversal code across your app.

[MISSING_PAGE_EMPTY:302]

Implement concrete iterator classes for the collections that you want to be traversable with iterators. An iterator object must be linked with a single collection instance. Usually, this link is established via the iterator's constructor.
4. Implement the collection interface in your collection classes. The main idea is to provide the client with a shortcut for creating iterators, tailored for a particular collection class. The collection object must pass itself to the iterator's constructor to establish a link between them.
5. Go over the client code to replace all of the collection traversal code with the use of iterators. The client fetches a new iterator object each time it needs to iterate over the collection elements.

### _Single Responsibility Principle_

You can clean up the client code and the collections by extracting bulky traversal algorithms into separate classes.

_Open/Closed Principle_

You can implement new types of collections and iterators and pass them to existing code without breaking anything.

You can iterate over the same collection in parallel because each iterator object contains its own iteration state.

For the same reason, you can delay an iteration and continue it when needed.

[MISSING_PAGE_EMPTY:304]

**Mediator** is a behavioral design pattern that lets you reduce chaotic dependencies between objects. The pattern restricts direct communications between the objects and forces them to collaborate only via a mediator object.

* 5. Problem

Say you have a dialog for creating and editing customer profiles. It consists of various form controls such as text fields, checkboxes, buttons, etc.

Some of the form elements may interact with others. For instance, selecting the "I have a dog" checkbox may reveal a hidden text field for entering the dog's name. Another example is the submit button that has to validate values of all fields before saving the data.

Elements can have lots of relations with other elements. Hence, changes to some elements may affect the others.

By having this logic implemented directly inside the code of the form elements you make these elements' classes much harder to reuse in other forms of the app. For example, you won't be able to use that checkbox class inside another form, because it's coupled to the dog's text field. You can use either all the classes involved in rendering the profile form, or none at all.

### 2 Solution

The Mediator pattern suggests that you should cease all direct communication between the components which you want to make independent of each other. Instead, these components must collaborate indirectly, by calling a special mediator object that redirects the calls to appropriate components. As a result, the components depend only on a single mediator class instead of being coupled to dozens of their colleagues.

In our example with the profile editing form, the dialog class itself may act as the mediator. Most likely, the dialog class is already aware of all of its sub-elements, so you won't even need to introduce new dependencies into this class.

The most significant change happens to the actual form elements. Let's consider the submit button. Previously, each time a user clicked the button, it had to validate the values of all individual form elements. Now its single job is to notify the dialog about the click. Upon receiving this notification, the dialog itself performs the validations or passes the task to the individual elements. Thus, instead of being tied to a dozen form elements, the button is only dependent on the dialog class.

You can go further and make the dependency even looser by extracting the common interface for all types of dialogs. The interface would declare the notification method which all form elements can use to notify the dialog about events happening to those elements. Thus, our submit button should now be able to work with any dialog that implements that interface.

This way, the Mediator pattern lets you encapsulate a complex web of relations between various objects inside a single mediator object. The fewer dependencies a class has, the easier it becomes to modify, extend or reuse that class.

Pilots of aircraft that approach or depart the airport control area don't communicate directly with each other. Instead, they speak to an air traffic controller, who sits in a tall tower somewhere near the airstrip. Without the air traffic controller, pilots would need to be aware of every plane in the vicinity of the airport, discussing landing priorities with a committee of dozens of other pilots. That would probably skyrocket the airplane crash statistics.

The tower doesn't need to control the whole flight. It exists only to enforce constraints in the terminal area because the number of involved actors there might be overwhelming to a pilot.

1. **Components** are various classes that contain some business logic. Each component has a reference to a mediator, declared with the type of the mediator interface. The component isn't aware of the actual class of the mediator, so you can reuse the component in other programs by linking it to a different mediator.
2. The **Mediator** interface declares methods of communication with components, which usually include just a single notification method. Components may pass any context as arguments of this method, including their own objects, but only in such a way that no coupling occurs between a receiving component and the sender's class.
3. **Concrete Mediators** encapsulate relations between various components. Concrete mediators often keep references to all components they manage and sometimes even manage their lifecycle.
4. Components must not be aware of other components. If something important happens within or to a component, it must only notify the mediator. When the mediator receives the notification, it can easily identify the sender, which might be just enough to decide what component should be triggered in return. From a component's perspective, it all looks like a total black box. The sender doesn't know who'll end up handling its request, and the receiver doesn't know who sent the request in the first place.

### Pseudocode

In this example, the **Mediator** pattern helps you eliminate mutual dependencies between various UI classes: buttons, checkboxes and text labels. An element, triggered by a user, doesn't communicate with other elements directly, even if it looks like it's supposed to. Instead, the element only needs to let its mediator know about the event, passing any contextual info along with that notification.

In this example, the whole authentication dialog acts as the mediator. It knows how concrete elements are supposed to collaborate and facilitates their indirect communication. Upon receiving a notification about an event, the dialog decides what element should address the event and redirects the call accordingly.

// The mediator interface declares a method used by components
2 // to notify the mediator about various events. The mediator may
3 // react to these events and pass the execution to other
4 // components.
5 interface Mediator is
6 method notify(sender: Component, event: string)
7
8
9 // The concrete mediator class. The intertwined web of
10 // connections between individual components has been untangled
11 // and moved into the mediator.
12 class AuthenticationDialog implements Mediator is
13 private field title: string
14 private field loginOrRegisterChkBx: Checkbox
15 private field loginUsername, loginPassword: Textbox
16 private field registrationUsername, registrationPassword
17 private field registrationEmail: Textbox
18 private field okBtn, canceIBtn: Button
19
20 constructor AuthenticationDialog() is
21 // Create all component objects and pass the current
22 // mediator into their constructors to establish links.
23
24 // When something happens with a component, it notifies the
25 // mediator. Upon receiving a notification, the mediator may
26 // do something on its own or pass the request to another
27 // component.
28 method notify(sender, event) is
29 if (sender == loginOrRegisterChkBx and event == "check")
30 if (loginOrRegisterChkBx.checked)
31 title = "Log in"
32 // 1. Show login form components.

[MISSING_PAGE_EMPTY:314]

[MISSING_PAGE_FAIL:315]

After you apply the Mediator, individual components become unaware of the other components. They could still communicate with each other, albeit indirectly, through a mediator object. To reuse a component in a different app, you need to provide it with a new mediator class.

Use the Mediator when you find yourself creating tons of component subclasses just to reuse some basic behavior in various contexts.

Since all relations between components are contained within the mediator, it's easy to define entirely new ways for these components to collaborate by introducing new mediator classes, without having to change the components themselves.

How to Implement

Identify a group of tightly coupled classes which would benefit from being more independent (e.g., for easier maintenance or simpler reuse of these classes).

Declare the mediator interface and describe the desired communication protocol between mediators and various components. In most cases, a single method for receiving notifications from components is sufficient.

This interface is crucial when you want to reuse component classes in different contexts. As long as the component works with its mediator via the generic interface, you can link the component with a different implementation of the mediator.
3. Implement the concrete mediator class. This class would benefit from storing references to all of the components it manages.
4. You can go even further and make the mediator responsible for the creation and destruction of component objects. After this, the mediator may resemble a **factory** or a **facade**.
5. Components should store a reference to the mediator object. The connection is usually established in the component's constructor, where a mediator object is passed as an argument.
6. Change the components' code so that they call the mediator's notification method instead of methods on other components. Extract the code that involves calling other components into the mediator class. Execute this code whenever the mediator receives notifications from that component.

### _Single Responsibility Principle_

You can extract the communications between various components into a single place, making it easier to comprehend and maintain.
7. _Open/Closed Principle_

You can introduce new mediators without having to change the actual components.
8. You can reduce coupling between various components of a program.

* [16] **You can reuse individual components more easily.**
* [17] **Over time a mediator can evolve into a** **God Object**.**
* [18] **Relations with Other Patterns**
* [19] **Chain of Responsibility, Command, Mediator and Observer address various ways of connecting senders and receivers of requests:**
* [20] **_Chain of Responsibility_ passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.**
* [21] **_Command_ establishes unidirectional connections between senders and receivers.**
* [22] **_Mediator_ eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.**
* [23] **_Observer_ lets receivers dynamically subscribe to and unsubscribe from receiving requests.**
* [24] **Facade and Mediator have similar jobs: they try to organize collaboration between lots of tightly coupled classes.**
* [25] **_Facade_ defines a simplified interface to a subsystem of objects, but it doesn't introduce any new functionality. The subsystem itself is unaware of the facade. Objects within the subsystem can communicate directly.*** _Mediator_ centralizes communication between components of the system. The components only know about the mediator object and don't communicate directly.
* The difference between **Mediator** and **Observer** is often elusive. In most cases, you can implement either of these patterns; but sometimes you can apply both simultaneously. Let's see how we can do that.

The primary goal of _Mediator_ is to eliminate mutual dependencies among a set of system components. Instead, these components become dependent on a single mediator object. The goal of _Observer_ is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.

There's a popular implementation of the Mediator pattern that relies on _Observer_. The mediator object plays the role of publisher, and the components act as subscribers which subscribe to and unsubscribe from the mediator's events. When _Mediator_ is implemented this way, it may look very similar to _Observer_.

When you're confused, remember that you can implement the Mediator pattern in other ways. For example, you can permanently link all the components to the same mediator object. This implementation won't resemble _Observer_ but will still be an instance of the Mediator pattern.

Now imagine a program where all components have become publishers, allowing dynamic connections between each other. There won't be a centralized mediator object, only a distributed set of observers.

**Memento** is a behavioral design pattern that lets you save and restore the previous state of an object without revealing the details of its implementation.

3. Problem

Imagine that you're creating a text editor app. In addition to simple text editing, your editor can format text, insert inline images, etc.

At some point, you decided to let users undo any operations carried out on the text. This feature has become so common over the years that nowadays people expect every app to have it. For the implementation, you chose to take the direct approach. Before performing any operation, the app records the state of all objects and saves it in some storage. Later, when a user decides to revert an action, the app fetches the latest snapshot from the history and uses it to restore the state of all objects.

Let's think about those state snapshots. How exactly would you produce one? You'd probably need to go over all the fields in an object and copy their values into storage. However, this would only work if the object had quite relaxed access restrictions to its contents. Unfortunately, most real objects won't let others peek inside them that easily, hiding all significant data in private fields.

Ignore that problem for now and let's assume that our objects behave like hippies: preferring open relations and keeping their state public. While this approach would solve the immediate problem and let you produce snapshots of objects' states at will, it still has some serious issues. In the future, you might decide to refactor some of the editor classes, or add or remove some of the fields. Sounds easy, but this would also require chaining the classes responsible for copying the state of the affected objects.

But there's more. Let's consider the actual "snapshots" of the editor's state. What data does it contain? At a bare minimum, it must contain the actual text, cursor coordinates, current scroll position, etc. To make a snapshot, you'd need to collect these values and put them into some kind of container.

Most likely, you're going to store lots of these container objects inside some list that would represent the history. Therefore the containers would probably end up being objects of one class. The class would have almost no methods, but lots of fields that mirror the editor's state. To allow other objects to write and read data to and from a snapshot, you'd probably need to make its fields public. That would expose all the editor's states, private or not. Other classes would become dependent on every little change to the snapshot class, which would otherwise happen within private fields and methods without affecting outer classes.

It looks like we've reached a dead end: you either expose all internal details of classes, making them too fragile, or restrict access to their state, making it impossible to produce snapshots. Is there any other way to implement the "undo"?

### Solution

All problems that we've just experienced are caused by broken encapsulation. Some objects try to do more than they are supposed to. To collect the data required to perform some action, they invade the private space of other objects instead of letting these objects perform the actual action.

The Memento pattern delegates creating the state snapshots to the actual owner of that state, the _originator_ object. Hence, instead of other objects trying to copy the editor's state from the "outside," the editor class itself can make the snapshot since it has full access to its own state.

The pattern suggests storing the copy of the object's state in a special object called _memento_. The contents of the memento aren't accessible to any other object except the one that produced it. Other objects must communicate with mementos using a limited interface which may allow fetching the snapshot's metadata (creation time, the name of the performed operation, etc.), but not the original object's state contained in the snapshot.

_The originator has full access to the memento, whereas the caretaker can only access the metadata._Such a restrictive policy lets you store mementos inside other objects, usually called _caretakers_. Since the caretaker works with the memento only via the limited interface, it's not able to tamper with the state stored inside the memento. At the same time, the originator has access to all fields inside the memento, allowing it to restore its previous state at will.

In our text editor example, we can create a separate history class to act as the caretaker. A stack of mementos stored inside the caretaker will grow each time the editor is about to execute an operation. You could even render this stack within the app's UI, displaying the history of previously performed operations to a user.

When a user triggers the undo, the history grabs the most recent memento from the stack and passes it back to the editor, requesting a roll-back. Since the editor has full access to the memento, it changes its own state with the values taken from the memento.

## 9 Structure

### Implementation based on nested classes

The classic implementation of the pattern relies on support for nested classes, available in many popular programming languages (such as C++, C#, and Java).

1. The **Originator** class can produce snapshots of its own state, as well as restore its state from snapshots when needed.
2. The **Memento** is a value object that acts as a snapshot of the originator's state. It's a common practice to make the memento immutable and pass it the data only once, via the constructor.
3. The **Caretaker** knows not only "when" and "why" to capture the originator's state, but also when the state should be restored.

A caretaker can keep track of the originator's history by storing a stack of mementos. When the originator has to travel back in history, the caretaker fetches the topmost memento from the stack and passes it to the originator's restoration method.
4. In this implementation, the memento class is nested inside the originator. This lets the originator access the fields and methods of the memento, even though they're declared private. On the other hand, the caretaker has very limited access to the memento's fields and methods, which lets it store mementos in a stack but not tamper with their state.

### Implementation based on an intermediate interface

There's an alternative implementation, suitable for programming languages that don't support nested classes (yeah, PHP, I'm talking about you).

1. In the absence of nested classes, you can restrict access to the memento's fields by establishing a convention that caretakers can work with a memento only through an explicitly declared intermediary interface, which would only declare methods related to the memento's metadata.
2. On the other hand, originators can work with a memento object directly, accessing fields and methods declared in the memento class. The downside of this approach is that you need to declare all members of the memento public.

### Implementation with even stricter encapsulation

There's another implementation which is useful when you don't want to leave even the slightest chance of other classes accessing the state of the originator through the memento.

1. This implementation allows having multiple types of originators and mementos. Each originator works with a corresponding memento class. Neither originators nor mementos expose their state to anyone.
2. Caretakers are now explicitly restricted from changing the state stored in mementos. Moreover, the caretaker class becomes independent from the originator because the restoration method is now defined in the memento class.
3. Each memento becomes linked to the originator that produced it. The originator passes itself to the mementos constructor, along with the values of its state. Thanks to the close relationship between these classes, a memento can restore the state of its originator, given that the latter has defined the appropriate setters.

## # Pseudocode

In this example uses the Memento pattern alongside the **Command** pattern for storing snapshots of the complex text editor's state and restoring an earlier state from these snapshots when needed.

_Saving snapshots of the text editor's state._The command objects act as caretakers. They fetch the editor's memento before executing operations related to commands. When a user attempts to undo the most recent command, the editor can use the memento stored in that command to revert itself to the previous state.

The memento class doesn't declare any public fields, getters or setters. Therefore no object can alter its contents. Mementos are linked to the editor object that created them. This lets a memento restore the linked editor's state by passing the data via setters on the editor object. Since mementos are linked to specific editor objects, you can make your app support several independent editor windows with a centralized undo stack.

```
1//Theoriginatorholdssomeimportantdatathatmaychangeover
2//time.Italsodefinesamethodforsavingitsstateinsidea
3//mementoandanothermethodforrestoringthestatefromit.
4classEditoris
5privatefieldtext,curX,curY,selectionWidth
6
7methodsetText(text)is
8this.text=text
9
10methodsetCursor(x,y)is
11this.curX=curX
12this.curY=curY
13
14methodsetSelectionWidth(width)is
15this.selectionWidth=width
16//Saves the current state inside a memento.
18method createSnapshot():Snapshot is
19//Memento is an immutable object; that's why the
20//originator passes its state to the memento's
21//constructor parameters.
22returnnew Snapshot(this, text, curX, curY, selectionWidth)
23
24//Thememento class stores the past state of the editor.
25class Snapshot is
26private field editor: Editor
27private field text, curX, curY, selectionWidth
28
29constructor Snapshot(editor, text, curX, curY, selectionWidth) is
30this.editor = editor
31this.text = text
32this.curX = curX
33this.curY = curY
34this.selectionWidth = selectionWidth
35
36//Atsomepoint, a previous state of the editor can be
37//restoredusingamementoobject.
38method restore() is
39editor.setText(text)
40editor.setCursor(curX, curY)
41editor.setSelectionWidth(selectionWidth)
42
43//Acommandobjectcanactasacretaker.Inthatcase,the
44//commandgetsamementojustbeforeitchangesthe
45//originator'sstate.Whenundoisrequested,itrestoresthe
46//originator'sstatefromamemento.
47classCommandis
48privatefieldbackup:Snapshotmethod makeBackup() is
50 backup = editor.createSnapshot()
51
52 method undo() is
53 if (backup!= null)
54 backup.restore()
55 //...

Applicability

Use the Memento pattern when you want to produce snapshots of the object's state to be able to restore a previous state of the object.

The Memento pattern lets you make full copies of an object's state, including private fields, and store them separately from the object. While most people remember this pattern thanks to the "undo" use case, it's also indispensable when dealing with transactions (i.e., if you need to roll back an operation on error).

Use the pattern when direct access to the object's fields/getters/setters violates its encapsulation.

The Memento makes the object itself responsible for creating a snapshot of its state. No other object can read the snapshot, making the original object's state data safe and secure.

## 4 How to Implement

1. Determine what class will play the role of the originator. It's important to know whether the program uses one central object of this type or multiple smaller ones.
2. Create the memento class. One by one, declare a set of fields that mirror the fields declared inside the originator class.
3. Make the memento class immutable. A memento should accept the data just once, via the constructor. The class should have no setters.
4. If your programming language supports nested classes, nest the memento inside the originator. If not, extract a blank interface from the memento class and make all other objects use it to refer to the memento. You may add some metadata operations to the interface, but nothing that exposes the originator's state.
5. Add a method for producing mementos to the originator class. The originator should pass its state to the memento via one or multiple arguments of the memento's constructor.

The return type of the method should be of the interface you extracted in the previous step (assuming that you extracted it at all). Under the hood, the memento-producing method should work directly with the memento class.

Add a method for restoring the originator's state to its class. It should accept a memento object as an argument. If you extracted an interface in the previous step, make it the type of the parameter. In this case, you need to typecast the incoming object to the mediator class, since the originator needs full access to that object.
7. The caretaker, whether it represents a command object, a history, or something entirely different, should know when to request new mementos from the originator, how to store them and when to restore the originator with a particular memento.
8. The link between caretakers and originators may be moved into the memento class. In this case, each memento must be connected to the originator that had created it. The restoration method would also move to the memento class. However, this would all make sense only if the memento class is nested into originator or the originator class provides sufficient setters for overriding its state.

### Pros and Cons

You can produce snapshots of the object's state without violating its encapsulation.

You can simplify the originator's code by letting the caretaker maintain the history of the originator's state.

The app might consume lots of RAM if clients create mementos too often.

* [leftmargin=*]
* **Carteakers should track the originator's lifecycle to be able to destroy obsolete mementos.**
* **Most dynamic programming languages, such as PHP, Python and JavaScript, can't guarantee that the state within the memento stays untouched.**
* **Relations with Other Patterns**
* **You can use Command and Memento together when implementing "undo". In this case, commands are responsible for performing various operations over a target object, while mementos save the state of that object just before a command gets executed.**
* **You can use Memento along with Iterator to capture the current iteration state and roll it back if necessary.**
* **Sometimes Prototype can be a simpler alternative to Memento. This works if the object, the state of which you want to store in the history, is fairly straightforward and doesn't have links to external resources, or the links are easy to re-establish.**

**Observer** is a behavioral design pattern that lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they're observing.

[MISSING_PAGE_EMPTY:338]

It looks like we've got a conflict. Either the customer wastes time checking product availability or the store wastes resources notifying the wrong customers.
* 2 Solution The object that has some interesting state is often called _subject_, but since it's also going to notify other objects about the changes to its state, we'll call it _publisher_. All other objects that want to track changes to the publisher's state are called _subscribers_.

The Observer pattern suggests that you add a subscription mechanism to the publisher class so individual objects can subscribe to or unsubscribe from a stream of events coming from that publisher. Fear not! Everything isn't as complicated as it sounds. In reality, this mechanism consists of 1) an array field for storing a list of references to subscriber objects and 2) several public methods which allow adding subscribers to and removing them from that list.

_A subscription mechanism lets individual objects subscribe to event notifications._

[MISSING_PAGE_EMPTY:340]

If your app has several different types of publishers and you want to make your subscribers compatible with all of them, you can go even further and make all publishers follow the same interface. This interface would only need to describe a few subscription methods. The interface would allow subscribers to observe publishers' states without coupling to their concrete classes.

### Real-World Analogy

If you subscribe to a newspaper or magazine, you no longer need to go to the store to check if the next issue is available. Instead, the publisher sends new issues directly to your mailbox right after publication or even in advance.

The publisher maintains a list of subscribers and knows which magazines they're interested in. Subscribers can leave the list at any time when they wish to stop the publisher sending new magazine issues to them.

### Structure

1. The **Publisher** issues events of interest to other objects. These events occur when the publisher changes its state or executes some behaviors. Publishers contain a subscription infrastructure that lets new subscribers join and current subscribers leave the list.
2. When a new event happens, the publisher goes over the subscription list and calls the notification method declared in the subscriber interface on each subscriber object.
3. The **Subscriber** interface declares the notification interface. In most cases, it consists of a single update method. The method may have several parameters that let the publisher pass some event details along with the update.

* [4]**Concrete Subscribers perform some actions in response to notifications issued by the publisher. All of these classes must implement the same interface so the publisher isn't coupled to concrete classes.
* [5] Usually, subscribers need some contextual information to handle the update correctly. For this reason, publishers often pass some context data as arguments of the notification method. The publisher can pass itself as an argument, letting subscriber fetch any required data directly.
* [6] The **Client** creates publisher and subscriber objects separately and then registers subscribers for publisher updates.

## # Pseudocode

In this example, the **Observer** pattern lets the text editor object notify other service objects about changes in its state.

The list of subscribers is compiled dynamically: objects can start or stop listening to notifications at runtime, depending on the desired behavior of your app.

In this implementation, the editor class doesn't maintain the subscription list by itself. It delegates this job to the special helper object devoted to just that. You could upgrade that object to serve as a centralized event dispatcher, letting any object act as a publisher.

[MISSING_PAGE_FAIL:345]

// Methods of business logic can notify subscribers about
29// changes.
30method openFile(path)is
31this.file = new File(path)
32events.notify("open", file.name)
33
34method saveFile()is
35file.write()
36events.notify("save", file.name)
37
38//...
39
40
41// Here's the subscriber interface. If your programming language,
42// supports functional types, you can replace the whole
43// subscriber hierarchy with a set of functions.
44interface EventListener is
45method update(filename)
46
47// Concrete subscribers react to updates issued by the publisher.
48// they are attached to.
49class LoggingListener implements EventListener is
50private field log: File
51private field message
52
53constructor LoggingListener(log_filename, message)is
54this.log = new File(log_filename)
55this.message = message
56
57method update(filename)is
58log.write(replace('ss',filename,message))classEmailAlertsListener implementsEventListener is
61 privatefieldemail:string
62
63 constructorEmailAlertsListener(email,message)is
64 this.email =email
65 this.message =message
66
67 methodupdate(filename)is
68 system.email(email,replace('%s',filename,message))
69
70
71 //An application can configure publishers and subscribers at
72 // runtime.
73 classApplication is
74 methodconfig()is
75 editor = newTextEditor()
76
77 logger = newLoggingListener(
78 "/path/to/log.txt",
79 "Someone has opened the file: %s");
80 editor.events.subscribe("open", logger)
81
82 emailAlerts = newEmailAlertsListener(
83 "admin@example.com",
84 "Someone has changed the file: %s")
85 editor.events.subscribe("save",emailAlerts)

### 2.3. Applicability

Use the Observer pattern when changes to the state of one object may require changing other objects, and the actual set of objects is unknown beforehand or changes dynamically.

You can often experience this problem when working with classes of the graphical user interface. For example, you created custom button classes, and you want to let the clients hook some custom code to your buttons so that it fires whenever a user presses a button.

The Observer pattern lets any object that implements the subscriber interface subscribe for event notifications in publisher objects. You can add the subscription mechanism to your buttons, letting the clients hook up their custom code via custom subscriber classes.

Use the pattern when some objects in your app must observe others, but only for a limited time or in specific cases.

The subscription list is dynamic, so subscribers can join or leave the list whenever they need to.

How to Implement

Look over your business logic and try to break it down into two parts: the core functionality, independent from other code, willact as the publisher; the rest will turn into a set of subscriber classes.
2. Declare the subscriber interface. At a bare minimum, it should declare a single update method.
3. Declare the publisher interface and describe a pair of methods for adding a subscriber object to and removing it from the list. Remember that publishers must work with subscribers only via the subscriber interface.
4. Decide where to put the actual subscription list and the implementation of subscription methods. Usually, this code looks the same for all types of publishers, so the obvious place to put it is in an abstract class derived directly from the publisher interface. Concrete publishers extend that class, inheriting the subscription behavior. However, if you're applying the pattern to an existing class hierarchy, consider an approach based on composition: put the subscription logic into a separate object, and make all real publishers use it.
5. Create concrete publisher classes. Each time something important happens inside a publisher, it must notify all its subscribers.
6. Implement the update notification methods in concrete subscriber classes. Most subscribers would need some context data about the event. It can be passed as an argument of the notification method. But there's another option. Upon receiving a notification, the subscriber can fetch any data directly from the notification. In this case, the publisher must pass itself via the update method. The less flexible option is to link a publisher to the subscriber permanently via the constructor.
7. The client must create all necessary subscribers and register them with proper publishers.

### Pros and Cons

_Open/Closed Principle._ You can introduce new subscriber classes without having to change the publisher's code (and vice versa if there's a publisher interface).

You can establish relations between objects at runtime.

### Subscribers are notified in random order.

Relations with Other Patterns

* **Chain of Responsibility, Command, Mediator and Observer**address various ways of connecting senders and receivers of requests:* _Chain of Responsibility_ passes a request sequentially along a dynamic chain of potential receivers until one of them handles it.
* _Command_ establishes unidirectional connections between senders and receivers.
* _Mediator_ eliminates direct connections between senders and receivers, forcing them to communicate indirectly via a mediator object.
* _Observer_ lets receivers dynamically subscribe to and unsubscribe from receiving requests.
* The difference between **Mediator** and **Observer** is often elusive. In most cases, you can implement either of these patterns; but sometimes you can apply both simultaneously. Let's see how we can do that.

The primary goal of _Mediator_ is to eliminate mutual dependencies among a set of system components. Instead, these components become dependent on a single mediator object. The goal of _Observer_ is to establish dynamic one-way connections between objects, where some objects act as subordinates of others.

There's a popular implementation of the Mediator pattern that relies on _Observer_. The mediator object plays the role of publisher, and the components act as subscribers which subscribe to and unsubscribe from the mediator's events. When _Mediator_ is implemented this way, it may look very similar to _Observer_.

When you're confused, remember that you can implement the Mediator pattern in other ways. For example, you can permanently link all the components to the same mediator object. This implementation won't resemble _Observer_ but will still be an instance of the Mediator pattern.

Now imagine a program where all components have become publishers, allowing dynamic connections between each other. There won't be a centralized mediator object, only a distributed set of observers.

**State** is a behavioral design pattern that lets an object alter its behavior when its internal state changes. It appears as if the object changed its class.

* 5. Problem The State pattern is closely related to the concept of a Finite-State Machine.

The main idea is that, at any given moment, there's a _finite_ number of _states_ which a program can be in. Within any unique state, the program behaves differently, and the program can be switched from one state to another instantaneously. However, depending on a current state, the program may or may not switch to certain other states. These switching rules, called _transitions_, are also finite and predetermined.

You can also apply this approach to objects. Imagine that we have a Document class. A document can be in one of three states: Draft, Moderation and Published. The publish method of the document works a little bit differently in each state:

[MISSING_PAGE_EMPTY:355]

[MISSING_PAGE_EMPTY:356]

## 5 Solution

The State pattern suggests that you create new classes for all possible states of an object and extract all state-specific behaviors into these classes.

Instead of implementing all behaviors on its own, the original object, called _context_, stores a reference to one of the state objects that represents its current state, and delegates all the state-related work to that object.

### Document delegates the work to a state object.

To transition the context into another state, replace the active state object with another object that represents that new state. This is possible only if all state classes follow the same interface and the context itself works with these objects through that interface.

This structure may look similar to the **Strategy** pattern, but there's one key difference. In the State pattern, the particular states may be aware of each other and initiate transitions from one state to another, whereas strategies almost never know about each other.

### Real-World Analogy

The buttons and switches in your smartphone behave differently depending on the current state of the device:

* When the phone is unlocked, pressing buttons leads to executing various functions.
* When the phone is locked, pressing any button leads to the unlock screen.
* When the phone's charge is low, pressing any button shows the charging screen.

1. **Context** stores a reference to one of the concrete state objects and delegates to it all state-specific work. The context communicates with the state object via the state interface. The context exposes a setter for passing it a new state object.
2. The **State** interface declares the state-specific methods. These methods should make sense for all concrete states because you don't want some of your states to have useless methods that will never be called.
3. **Concrete States** provide their own implementations for the state-specific methods. To avoid duplication of similar code across multiple states, you may provide intermediate abstract classes that encapsulate some common behavior.

State objects may store a backreference to the context object. Through this reference, the state can fetch any required info from the context object, as well as initiate state transitions.
4. Both context and concrete states can set the next state of the context and perform the actual state transition by replacing the state object linked to the context.

## # Pseudocode

In this example, the **State** pattern lets the same controls of the media player behave differently, depending on the current playback state.

_Example of changing object behavior with state objects._The main object of the player is always linked to a state object that performs most of the work for the player. Some actions replace the current state object of the player with another, which changes the way the player reacts to user interactions.

```
1//TheAudioPlayerclassactsasancontext.Italsomaintainsa
2//referencetoaninstanceofoneofthestatclassesthat
3//representsthecurrentstateoftheaudioplayer.
4classAudioPlayeris
5fieldstate:State
6fieldUI,volume,playlist,currentSong
7
8constructorAudioPlayer()is
9this.state=newReadyState(this)
10
11//Contextdelegateshandlinguserinputtoastate
12//object.Naturally,theoutcomedependsonwhatstate
13//iscurrentlyactive,sinceeachstatecanhandlethe
14//inputdifferently.
15UI=newUserInterface()
16UI.lockButton.onClick(this.clickLock)
17UI.playButton.onClick(this.clickPlay)
18UI.nextButton.onClick(this.clickNext)
19UI.prevButton.onClick(this.clickPrevious)
20
21//Otherobjectsmustbeabletoswitchtheaudioplayer's
22//activestate.
23methodchangeState(state:State)is
24this.state=state
25

[MISSING_PAGE_FAIL:362]

[MISSING_PAGE_EMPTY:363]

[MISSING_PAGE_EMPTY:364]

[MISSING_PAGE_EMPTY:365]

The State pattern lets you compose hierarchies of state classes and reduce duplication by extracting common code into abstract base classes.

How to Implement

1. Decide what class will act as the context. It could be an existing class which already has the state-dependent code; or a new class, if the state-specific code is distributed across multiple classes.
2. Declare the state interface. Although it may mirror all the methods declared in the context, aim only for those that may contain state-specific behavior.
3. For every actual state, create a class that derives from the state interface. Then go over the methods of the context and extract all code related to that state into your newly created class. While moving the code to the state class, you might discover that it depends on private members of the context. There are several workarounds: * Make these fields or methods public. * Turn the behavior you're extracting into a public method in the context and call it from the state class. This way is ugly but quick, and you can always fix it later.

* [5] _Test the state classes into the context class, but only if your programming language supports nesting classes._
* [6] _In the context class, add a reference field of the state interface type and a public setter that allows overriding the value of that field._
* [7] _Go over the method of the context again and replace empty state conditionals with calls to corresponding methods of the state object._
* [8] _To switch the state of the context, create an instance of one of the state classes and pass it to the context. You can do this within the context itself, or in various states, or in the client. Wherever this is done, the class becomes dependent on the concrete state class that it instantiates._

* [9] _Pros and Cons_
* [10] _Single Responsibility Principle._ _Organize the code related to particular states into separate classes._
* [11] _Open/Closed Principle._ _Introduce new states without changing existing state classes or the context._
* [12] _Simplify the code of the context by eliminating bulky state machine conditionals._
* [13] _Applying the pattern can be overkill if a state machine has only a few states or rarely changes._Relations with Other Patterns

* **Bridge**, **State**, **Strategy** (and to some degree **Adapter**) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn't just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.
* **State** can be considered as an extension of **Strategy**. Both patterns are based on composition: they change the behavior of the context by delegating some work to helper objects. _Strategy_ makes these objects completely independent and unaware of each other. However, _State_ doesn't restrict dependencies between concrete states, letting them alter the state of the context at will.

**Strategy** is a behavioral design pattern that lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable.

[MISSING_PAGE_FAIL:370]

While from a business perspective the app was a success, the technical part caused you many headaches. Each time you added a new routing algorithm, the main class of the navigator doubled in size. At some point, the beast became too hard to maintain.

Any change to one of the algorithms, whether it was a simple bug fix or a slight adjustment of the street score, affected the whole class, increasing the chance of creating an error in already-working code.

In addition, teamwork became inefficient. Your teammates, who had been hired right after the successful release, complain that they spend too much time resolving merge conflicts. Implementing a new feature requires you to change the same huge class, conflicting with the code produced by other people.

## 5 Solution

The Strategy pattern suggests that you take a class that does something specific in a lot of different ways and extract all of these algorithms into separate classes called _strategies_.

The original class, called _context_, must have a field for storing a reference to one of the strategies. The context delegates the work to a linked strategy object instead of executing it on its own.

The context isn't responsible for selecting an appropriate algorithm for the job. Instead, the client passes the desired strategy to the context. In fact, the context doesn't know much about strategies. It works with all strategies through the same generic interface, which only exposes a single method for triggering the algorithm encapsulated within the selected strategy.

This way the context becomes independent of concrete strategies, so you can add new algorithms or modify existing ones without changing the code of the context or other strategies.

In our navigation app, each routing algorithm can be extracted to its own class with a single buildRoute method. The method accepts an origin and destination and returns a collection of the route's checkpoints.

Even though given the same arguments, each routing class might build a different route, the main navigator class doesn'treally care which algorithm is selected since its primary job is to render a set of checkpoints on the map. The class has a method for switching the active routing strategy, so its clients, such as the buttons in the user interface, can replace the currently selected routing behavior with another one.

Imagine that you have to get to the airport. You can catch a bus, order a cab, or get on your bicycle. These are your transportation strategies. You can pick one of the strategies depending on factors such as budget or time constraints.

1. The **Context** maintains a reference to one of the concrete strategies and communicates with this object only via the strategy interface.
2. The **Strategy** interface is common to all concrete strategies. It declares a method the context uses to execute a strategy.
3. **Concrete Strategies** implement different variations of an algorithm the context uses.

The context calls the execution method on the linked strategy object each time it needs to run the algorithm. The context doesn't know what type of strategy it works with or how the algorithm is executed.
5. The **Client** creates a specific strategy object and passes it to the context. The context exposes a setter which lets clients replace the strategy associated with the context at runtime.

## # Pseudocode

In this example, the context uses multiple strategies to execute various arithmetic operations.

1 // The strategy interface declares operations common to all
2 // supported versions of some algorithm. The context uses this
3 // interface to call the algorithm defined by the concrete
4 // strategies.
5 **interface Strategy is**
6 **method** execute(a, b)
7
8 // Concrete strategies implement the algorithm while following
9 // the base strategy interface. The interface makes them
10 // interchangeable in the context.
11 **class** ConcreteStrategyAdd implements Strategy is
12 **method** execute(a, b) **is**
13 **return** a + b
14
15 **class** ConcreteStrategySubtract implements Strategy is
16 **method** execute(a, b) **is**

[MISSING_PAGE_EMPTY:376]

Create context object.
* 50
* 51 Read first number.
* 52 Read last number.
* 53 Read the desired action from user input.
* 54
* 55 **if** (action == addition) **then**
* 56 context.setStrategy(**new** ConcreteStrategyAdd())
* 57
* 58 **if** (action == subtraction) **then**
* 59 context.setStrategy(**new** ConcreteStrategySubtract())
* 60
* 61 **if** (action == multiplication) **then**
* 62 context.setStrategy(**new** ConcreteStrategyMultiply())
* 63
* 64 result = context.executeStrategy(First number, Second number)
* 65
* 66 Print result.

* 67 Applicability
* 68 Use the Strategy pattern when you want to use different variants of an algorithm within an object and be able to switch from one algorithm to another during runtime.
* 69 The Strategy pattern lets you indirectly alter the object's behavior at runtime by associating it with different sub-objects which can perform specific sub-tasks in different ways.

Use the Strategy when you have a lot of similar classes that only differ in the way they execute some behavior.

The Strategy pattern lets you extract the varying behavior into a separate class hierarchy and combine the original classes into one, thereby reducing duplicate code.

Use the pattern to isolate the business logic of a class from the implementation details of algorithms that may not be as important in the context of that logic.

The Strategy pattern lets you isolate the code, internal data, and dependencies of various algorithms from the rest of the code. Various clients get a simple interface to execute the algorithms and switch them at runtime.

Use the pattern when your class has a massive conditional operator that switches between different variants of the same algorithm.

The Strategy pattern lets you do away with such a conditional by extracting all algorithms into separate classes, all of which implement the same interface. The original object delegates execution to one of these objects, instead of implementing all variants of the algorithm.

## 4 How to Implement

1. In the context class, identify an algorithm that's prone to frequent changes. It may also be a massive conditional that selects and executes a variant of the same algorithm at runtime.
2. Declare the strategy interface common to all variants of the algorithm.
3. One by one, extract all algorithms into their own classes. They should all implement the strategy interface.
4. In the context class, add a field for storing a reference to a strategy object. Provide a setter for replacing values of that field. The context should work with the strategy object only via the strategy interface. The context may define an interface which lets the strategy access its data.
5. Clients of the context must associate it with a suitable strategy that matches the way they expect the context to perform its primary job.

## 5 Pros and Cons

You can swap algorithms used inside an object at runtime.

You can isolate the implementation details of an algorithm from the code that uses it.

You can replace inheritance with composition.

_Open/Closed Principle._ You can introduce new strategies without having to change the context.

* If you only have a couple of algorithms and they rarely change, there's no real reason to overcomplicate the program with new classes and interfaces that come along with the pattern.
* Clients must be aware of the differences between strategies to be able to select a proper one.
* A lot of modern programming languages have functional type support that lets you implement different versions of an algorithm inside a set of anonymous functions. Then you could use these functions exactly as you'd have used the strategy objects, but without bloating your code with extra classes and interfaces.

* Relations with Other Patterns

* **Bridge**, **State**, **Strategy** (and to some degree **Adapter**) have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn't just a recipe for structuring your code in a specific way. It can also communicate to other developers the problem the pattern solves.
* **Command** and **Strategy** may look similar because you can use both to parameterize an object with some action. However, they have very different intents.

You can use _Command_ to convert any operation into an object. The operation's parameters become fields of that object. The conversion lets you defer execution of the operation, queue it, store the history of commands, send commands to remote services, etc.
* On the other hand, _Strategy_ usually describes different ways of doing the same thing, letting you swap these algorithms within a single context class.
* **Decorator** lets you change the skin of an object, while **Strategy** lets you change the guts.
* **Template Method** is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. **Strategy** is based on composition: you can alter parts of the object's behavior by supplying it with different strategies that correspond to that behavior. _Template Method_ works at the class level, so it's static. _Strategy_ works on the object level, letting you switch behaviors at runtime.
* **State** can be considered as an extension of **Strategy**. Both patterns are based on composition: they change the behavior of the context by delegating some work to helper objects. _Strategy_ makes these objects completely independent and unaware of each other. However, _State_ doesn't restrict dependencies between concrete states, letting them alter the state of the context at will.

**Template Method** is a behavioral design pattern that defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.

* 5. Problem

Imagine that you're creating a data mining application that analyzes corporate documents. Users feed the app documents in various formats (PDF, DOC, CSV), and it tries to extract meaningful data from these docs in a uniform format.

The first version of the app could work only with DOC files. In the following version, it was able to support CSV files. A month later, you "taught" it to extract data from PDF files.

At some point, you noticed that all three classes have a lot of similar code. While the code for dealing with various data formats was entirely different in all classes, the code for data pro cessing and analysis is almost identical. Wouldn't it be great to get rid of the code duplication, leaving the algorithm structure intact?

There was another problem related to client code that used these classes. It had lots of conditionals that picked a proper course of action depending on the class of the processing object. If all three processing classes had a common interface or a base class, you'd be able to eliminate the conditionals in client code and use polymorphism when calling methods on a processing object.

### Solution

The Template Method pattern suggests that you break down an algorithm into a series of steps, turn these steps into methods, and put a series of calls to these methods inside a single "template method." The steps may either be abstract, or have some default implementation. To use the algorithm, the client is supposed to provide its own subclass, implement all abstract steps, and override some of the optional ones if needed (but not the template method itself).

Let's see how this will play out in our data mining app. We can create a base class for all three parsing algorithms. This class defines a template method consisting of a series of calls to various document-processing steps.

At first, we can declare all steps abstract, forcing the subclasses to provide their own implementations for these methods. In our case, subclasses already have all necessary implementations, so the only thing we might need to do is adjust signatures of the methods to match the methods of the superclass.

Now, let's see what we can do to get rid of the duplicate code. It looks like the code for opening/closing files and extracting/ parsing data is different for various data formats, so there's no point in touching those methods. However, implementation of other steps, such as analyzing the raw data and composing reports, is very similar, so it can be pulled up into the base class, where subclasses can share that code.

As you can see, we've got two types of steps:

* _abstract steps_ must be implemented by every subclass
* _optional steps_ already have some default implementation, but still can be overridden if needed There's another type of step, called _hooks_. A hook is an optional step with an empty body. A template method would work even if a hook isn't overridden. Usually, hooks are placed before and after crucial steps of algorithms, providing subclasses with additional extension points for an algorithm.

The template method approach can be used in mass housing construction. The architectural plan for building a standard house may contain several extension points that would let a potential owner adjust some details of the resulting house.

Each building step, such as laying the foundation, framing, building walls, installing plumbing and wiring for water and electricity, etc., can be slightly changed to make the resulting house a little bit different from others.

### Structure

1. The **Abstract Class** declares methods that act as steps of an algorithm, as well as the actual template method which calls these methods in a specific order. The steps may either be declared abstract or have some default implementation.

2. **Concrete Classes** can override all of the steps, but not the template method itself.

## # Pseudocode

In this example, the **Template Method** pattern provides a "skeleton" for various branches of artificial intelligence in a simple strategy video game.

All races in the game have almost the same types of units and buildings. Therefore you can reuse the same AI structure for various races, while being able to override some of the details. With this approach, you can override the orcs' AI to make it more aggressive, make humans more defense-oriented, and make monsters unable to build anything. Adding a new race to the game would require creating a new AI subclass and overriding the default methods declared in the base AI class.

```
1//Theabstractclassdefinesattemplatedthatcontainsa
2//skeletonofsomealgorithmcomposedofcalls,usuallyto
3//abstractprimitiveoperations.Concretesubclassesimplement
4//theseoperations,butleavethetemplatemethoditself
5//intact.
6classGameAIis
7//Thetemplatemethoddefinestheskeletonofanalgorithm.
8methodturn()is
9collectResources()
10buildStructures()
11buildUnits()
12attack()
13
14//Someofthestepsmaybeimplementedrightinabase
15//class.
16methodcollectResources()is
17foreach(sinthis.builtStructures)do
18s.collect()
19
20//Andsomeofthemmaybedefinedasabstract.
21abstractmethodbuildStructures()
22abstractmethodbuildUnits()
23
24//Aclasscanhaveseveraltemplatemethods.
25methodattack()is
26enemy=closestEnemy()
27if(enemy==null)
```

[MISSING_PAGE_EMPTY:390]

// Subclasses can also override some operations with a default
61 // implementation.
62 class MonstersAI extends GameAI is
63 method collectResources() is
64 // Monsters don't collect resources.
65
66 method buildStructures() is
67 // Monsters don't build structures.
68
69 method buildUnits() is
70 // Monsters don't build units.

### Applicability

The Template Method lets you turn a monolithic algorithm into a series of individual steps which can be easily extended by subclasses while keeping intact the structure defined in a superclass.

Use the pattern when you have several classes that contain almost identical algorithms with some minor differences. As a result, you might need to modify both classes when the algorithm changes.

When you turn such an algorithm into a template method, you can also pull up the steps with similar implementations into a superclass, eliminating code duplication. Code that varies between subclasses can remain in subclasses.

### How to Implement

1. Analyze the target algorithm to see whether you can break it into steps. Consider which steps are common to all subclasses and which ones will always be unique.
2. Create the abstract base class and declare the template method and a set of abstract methods representing the algorithm's steps. Outline the algorithm's structure in the template method by executing corresponding steps. Consider making the template method final to prevent subclasses from overriding it.
3. It's okay if all the steps end up being abstract. However, some steps might benefit from having a default implementation. Subclasses don't have to implement those methods.
4. Think of adding hooks between the crucial steps of the algorithm.
5. For each variation of the algorithm, create a new concrete subclass. It _must_ implement all of the abstract steps, but _may_ also override some of the optional ones.

* **Pros and Cons**
* You can let clients override only certain parts of a large algorithm, making them less affected by changes that happen to other parts of the algorithm.
* You can pull the duplicate code into a superclass.
* Some clients may be limited by the provided skeleton of an algorithm.
* You might violate the _Liskov Substitution Principle_ by suppressing a default step implementation via a subclass.
* Template methods tend to be harder to maintain the more steps they have.
* **Relations with Other Patterns**
* **Factory Method** is a specialization of **Template Method**. At the same time, a _Factory Method_ may serve as a step in a large _Template Method_.
* **Template Method** is based on inheritance: it lets you alter parts of an algorithm by extending those parts in subclasses. **Strategy** is based on composition: you can alter parts of the object's behavior by supplying it with different strategies that correspond to that behavior. _Template Method_ works at the class level, so it's static. _Strategy_ works on the object level, letting you switch behaviors at runtime.

**Visitor** is a behavioral design pattern that lets you separate algorithms from the objects on which they operate.

* 3. Problem
* 4. Imagine that your team develops an app which works with geographic information structured as one colossal graph. Each node of the graph may represent a complex entity such as a city, but also more granular things like industries, sightseeing areas, etc. The nodes are connected with others if there's a road between the real objects that they represent. Under the hood, each node type is represented by its own class, while each specific node is an object.

At some point, you got a task to implement exporting the graph into XML format. At first, the job seemed pretty straightforward. You planned to add an export method to each node class and then leverage recursion to go over each node of the graph, executing the export method. The solution was simple and elegant: thanks to polymorphism, you weren't coupling the code which called the export method to concrete classes of nodes.

Unfortunately, the system architect refused to allow you to alter existing node classes. He said that the code was already in production and he didn't want to risk breaking it because of a potential bug in your changes.

Besides, he questioned whether it makes sense to have the XML export code within the node classes. The primary job of these classes was to work with geodata. The XML export behavior would look alien there.

There was another reason for the refusal. It was highly likely that after this feature was implemented, someone from the marketing department would ask you to provide the ability to export into a different format, or request some other weird stuff. This would force you to change those precious and fragile classes again.

* 2 Solution The Visitor pattern suggests that you place the new behavior into a separate class called _visitor_, instead of trying to integrate it into existing classes. The original object that had to perform the behavior is now passed to one of the visitor's methods as an argument, providing the method access to all necessary data contained within the object.

Now, what if that behavior can be executed over objects of different classes? For example, in our case with XML export, the actual implementation will probably be a little bit different across various node classes. Thus, the visitor class may define not one, but a set of methods, each of which could take arguments of different types, like this:

```
1classExportVisitorimplementsVisitoris
2methoddoForCity(Cityc){...}
3methoddoForIndustry(Industryf){...}
4methoddoForSightSeeing(SightSeeingss){...}
5//...
```

But how exactly would we call these methods, especially when dealing with the whole graph? These methods have different signatures, so we can't use polymorphism. To pick a proper visitor method that's able to process a given object, we'd need to check its class. Doesn't this sound like a nightmare?```
1foreach(Nodenodeingraph)
2if(nodeinstanceofCity)
3exportVisitor.doForCity((City)node)
4if(nodeinstanceofIndustry)
5exportVisitor.doForIndustry((Industry)node)
6//...
7}
```

You might ask, why don't we use method overloading? That's when you give all methods the same name, even if they support different sets of parameters. Unfortunately, even assuming that our programming language supports it at all (as Java and C# do), it won't help us. Since the exact class of a node object is unknown in advance, the overloading mechanism won't be able to determine the correct method to execute. It'll default to the method that takes an object of the base Node class.

However, the Visitor pattern addresses this problem. It uses a technique called **Double Dispatch**, which helps to execute the proper method on an object without cumbersome conditionals. Instead of letting the client select a proper version of the method to call, how about we delegate this choice to objects we're passing to the visitor as an argument?

Since the objects know their own classes, they'll be able to pick a proper method on the visitor less awkwardly. They "accept" a visitor and tell it what visiting method should be executed.

[MISSING_PAGE_EMPTY:399]

Imagine a seasoned insurance agent who's eager to get new customers. He can visit every building in a neighborhood, trying to sell insurance to everyone he meets. Depending on the type of organization that occupies the building, he can offer specialized insurance policies:

* If it's a residential building, he sells medical insurance.
* If it's a bank, he sells theft insurance.
* If it's a coffee shop, he sells fire and flood insurance.

The **Visitor** interface declares a set of visiting methods that can take concrete elements of an object structure as arguments. These methods may have the same names if the program is written in a language that supports overloading, but the type of their parameters must be different.

* [2] Each Concrete Visitor implements several versions of the same behaviors, tailored for different concrete element classes.
* [3] The **Element** interface declares a method for "accepting" visitors. This method should have one parameter declared with the type of the visitor interface.
* [4] Each **Concrete Element** must implement the acceptance method. The purpose of this method is to redirect the call to the proper visitor's method corresponding to the current element class. Be aware that even if a base element class implements this method, all subclasses must still override this method in their own classes and call the appropriate method on the visitor object.
* [5] The **Client** usually represents a collection or some other complex object (for example, a **Composite** tree). Usually, clients aren't aware of all the concrete element classes because they work with objects from that collection via some abstract interface.
* [6] Pseudocode

In this example, the **Visitor** pattern adds XML export support to the class hierarchy of geometric shapes.

1// The element interface declares an 'accept' method that
2// takes the base visitor interface as an argument.
3interface Shape is
4method move(x, y)
5method draw()
6method accept(v: Visitor)
7
8// Each concrete element class must implement the 'accept'
9// method in such a way that it calls the visitor's method that
10// corresponds to the element's class.
11class Dot extends Shape is
12// mix // Note that we're calling 'visitDot', which matches the
14 // current class name. This way we let the visitor know the
15 // class of the element it works with.
16 method accept(v: Visitor) is
17 v.visitDot(this)
18
19 class Circle extends Dot is
20 //...
21 method accept(v: Visitor) is
22 v.visitCircle(this)
23
24 class Rectangle extends Shape is
25 //...
26 method accept(v: Visitor) is
27 v.visitRectangle(this)
28
29 class CompoundShape implements Shape is
30 //...
31 method accept(v: Visitor) is
32 v.visitCompoundShape(this)
33
34
35 // The Visitor interface declares a set of visiting methods that
36 // correspond to element classes. The signature of a visiting
37 // method lets the visitor identify the exact class of the
38 // element that it's dealing with.
39 interface Visitor is
40 method visitDot(d: Dot)
41 method visitCircle(c: Circle)
42 method visitRectangle(r: Rectangle)
43 method visitCompoundShape(cs: CompoundShape)

[MISSING_PAGE_FAIL:405]

method export() is exportVisitor = new XMLExportVisitor()
79
80 foreach (shape in alUShapes) do
81 shape.accept(exportVisitor) ```

If you wonder why we need the accept method in this example, my article **Visitor and Double Dispatch** addresses this question in detail.

### Applicability

The Visitor pattern lets you execute an operation over a set of objects with different classes by having a visitor object implement several variants of the same operation, which correspond to all target classes.

### Use the Visitor to clean up the business logic of auxiliary behaviors.

The pattern lets you make the primary classes of your app more focused on their main jobs by extracting all other behaviors into a set of visitor classes.

* [1] Use the pattern when a behavior makes sense only in some classes of a class hierarchy, but not in others.
* [2] You can extract this behavior into a separate visitor class and implement only those visiting methods that accept objects of relevant classes, leaving the rest empty.
* [3] How to Implement
* [1] Declare the visitor interface with a set of "visiting" methods, one per each concrete element class that exists in the program.
* [2] Declare the element interface. If you're working with an existing element class hierarchy, add the abstract "acceptance" method to the base class of the hierarchy. This method should accept a visitor object as an argument.
* [3] Implement the acceptance methods in all concrete element classes. These methods must simply redirect the call to a visiting method on the incoming visitor object which matches the class of the current element.
* [4] The element classes should only work with visitors via the visitor interface. Visitors, however, must be aware of all concrete element classes, referenced as parameter types of the visiting methods.

For each behavior that can't be implemented inside the element hierarchy, create a new concrete visitor class and implement all of the visiting methods.

You might encounter a situation where the visitor will need access to some private members of the element class. In this case, you can either make these fields or methods public, violating the element's encapsulation, or nest the visitor class in the element class. The latter is only possible if you're lucky to work with a programming language that supports nested classes.

6. The client must create visitor objects and pass them into elements via "acceptance" methods.

### Pros and Cons

_Open/Closed Principle._ You can introduce a new behavior that can work with objects of different classes without changing these classes.

_Single Responsibility Principle._ You can move multiple versions of the same behavior into the same class.

A visitor object can accumulate some useful information while working with various objects. This might be handy when you want to traverse some complex object structure, such as an object tree, and apply the visitor to each object of this structure.

You need to update all visitors each time a class gets added to or removed from the element hierarchy.
* Visitors might lack the necessary access to the private fields and methods of the elements that they're supposed to work with.
* Relations with Other Patterns
* You can treat **Visitor** as a powerful version of the **Command** pattern. Its objects can execute operations over various objects of different classes.
* You can use **Visitor** to execute an operation over an entire **Composite** tree.
* You can use **Visitor** along with **Iterator** to traverse a complex data structure and execute some operation over its elements, even if they all have different classes.

Conclusion

Congrats! You have reached the end of the book!

However, there are many other patterns in the world. I hope that the book will become your starting point for learning patterns and developing superhero program design abilities.

Here are a couple of ideas that will help you decide what to do next.

* </> Don't forget that you also have access to an archive of downloadable code samples in different programming languages.
* Read Joshua Kerievsky's "Refactoring To Patterns".
* [20] Know nothing about refactoring? I have a course for you.
* Print out these patterns cheat sheets and put them somewhere where you'll be able to see them all the time.
* [21] **Q** **Leave feedback** on this book. I'll be very excited to learn your opinion, even a highly critical one *